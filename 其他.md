# 其他

## MVC（Model-View-Controller）

MVC（Model-View-Controller）是一种软件设计模式，常用于构建可维护性和可扩展性高的Web应用程序。这种模式将应用程序的不同部分分离开来，使得它们各自负责不同的职责，从而提高了代码的组织性和可重用性。下面是MVC模式的三个主要组件及其作用：

1. Model（模型）：
   - 模型代表应用程序的数据和业务逻辑。它负责处理数据的存储、检索和业务规则的执行。
   - 当视图或控制器需要数据时，模型会被询问，然后返回所需的信息。
   - 模型通常与数据库或其他数据源交互，但不直接与视图或控制器交互。
2. View（视图）：
   - 视图是用户看到和与之交互的界面。它可以是HTML、XML、JSON或其他任何可以显示数据的格式。
   - 视图从模型中获取数据，并根据这些数据呈现用户界面。
   - 视图不包含任何业务逻辑，仅负责数据的展示，通常根据模型数据的变化自动更新。
3. Controller（控制器）：
   - 控制器是模型和视图之间的中介。它接收来自用户的输入（如HTTP请求），解析这些请求，然后调用适当的模型方法来处理数据。
   - 控制器根据模型返回的结果，决定如何更新视图。它还可以处理用户输入的验证、导航决策等任务。
   - 控制器返回响应给客户端，这个响应可能包含重定向、视图的渲染结果或其他指示。

在MVC架构中，当用户与视图交互（比如点击按钮或填写表单）时，请求被发送到控制器。控制器处理请求，可能更新模型，然后根据需要选择一个视图来显示更新后的数据。这种分离使得开发人员可以独立地修改视图、模型或控制器，而不会影响其他部分，从而提高了代码的可维护性和可测试性。

### SpringBoot的三层架构

#### 控制（Controller）层

Controller层负责接收用户的请求，解析请求参数，调用相应的服务或者业务逻辑进行处理，然后将处理结果封装成适当的响应返回给用户或者视图层。

Controller层通常包括以下功能：

1. **接收请求**：从客户端接收请求，可以是HTTP请求、用户输入等。
2. **解析参数**：解析请求中的参数，以便确定需要执行的操作以及操作所需的数据。
3. **调用服务**：根据请求调用相应的服务、业务逻辑或者模型来处理请求，并传递必要的数据。
4. **处理逻辑**：执行业务逻辑，可能包括数据验证、计算、持久化等操作。
5. **生成响应**：将处理结果封装成适当的响应格式，通常是将数据返回给客户端或者视图层。
6. **路由控制**：根据请求的URL或者其他标识符，将请求路由到正确的Controller处理。

#### 服务（Service）层

Service层的作用是实现应用程序的业务逻辑。它通常包含了与数据处理、计算、验证等相关的代码，以满足应用程序的功能需求。Service层位于Controller层和Repository（数据访问层）之间，负责处理业务逻辑，与数据访问层进行交互，并返回处理结果给Controller层。

Service层通常包括以下功能：

1. **实现业务逻辑**：根据应用程序的需求，编写业务逻辑代码，包括数据处理、计算、验证等。
2. **调用Repository**：与数据访问层（Repository）进行交互，执行数据库查询、更新、删除等操作。
3. **事务管理**：管理业务操作的事务，确保在一系列操作中的一致性和完整性。
4. **异常处理**：处理业务逻辑中可能出现的异常情况，确保应用程序的稳定性和可靠性。
5. **业务规则执行**：执行应用程序中定义的业务规则，确保数据的有效性和一致性。
6. **日志记录**：记录业务操作的日志，以便进行故障排查、性能优化等。

##### **接口/实现分离**

将服务层（Service Layer）的代码分成接口包和实现包是一种常见的设计模式，通常被称为接口和实现的分离。这种做法有以下几个好处：

1. **松耦合性（Loose Coupling）**：通过定义接口和实现的分离，可以实现服务层与其他层（如控制器、持久层）之间的松耦合。控制器层可以仅依赖于接口，而不需要了解具体的实现细节，从而降低了模块之间的耦合度，提高了代码的灵活性和可维护性。
2. **可扩展性（Scalability）**：将服务层的代码分成接口和实现包，使得在需要扩展功能或替换实现时更加容易。可以通过编写新的实现类来扩展服务层的功能，而不需要修改调用方的代码，实现了开闭原则（Open Closed Principle）。
3. **单一职责原则（Single Responsibility Principle）**：接口和实现的分离有助于确保每个类都只有一个单一的责任。接口定义了服务层的功能接口，而实现类负责实现具体的业务逻辑，这样每个类都更加专注于自己的职责，提高了代码的可读性和可维护性。
4. **依赖注入（Dependency Injection）**：接口和实现的分离使得依赖注入变得更加容易。通过依赖注入框架（如Spring），可以将服务层的实现类注入到其他组件中，而无需直接实例化具体的实现类，从而实现了解耦和灵活的组件管理。

综上所述，将服务层的代码分成接口包和实现包有助于降低模块之间的耦合度，提高代码的可维护性、可扩展性和可读性，是一种良好的设计实践。

#### 持久化（Mapper）层

Mapper层的作用是在软件系统中实现对象关系映射（ORM），将数据库中的数据与应用程序中的对象进行映射和转换。以下是Mapper层的主要作用：

1. **数据持久化**：Mapper层负责将应用程序中的对象持久化到数据库中，或从数据库中检索对象并映射到应用程序中的对象。这包括将对象转换为适合存储在数据库中的格式，并将数据库中的数据转换为应用程序可用的对象。
2. **对象关系映射**：Mapper层管理对象之间的关系，并将这些关系映射到数据库中的表结构。它能够处理对象之间的一对一、一对多、多对一和多对多等各种关系。
3. **数据操作**：Mapper层提供了对数据库的基本操作，如插入、更新、删除和查询数据。这些操作通常通过ORM框架提供的方法来实现，简化了对数据库的操作过程。
4. **性能优化**：Mapper层可以实现一些性能优化策略，如延迟加载（Lazy Loading）、缓存和批量操作，以提高系统的性能和效率。
5. **领域模型与数据库模式之间的转换**：Mapper层负责将领域模型中的对象属性映射到数据库中的表列，并处理它们之间的数据类型转换和约束。

### 案例

在一个使用SpringBoot+MyBatis+MySQL+Vue构建的前后端分离项目中，虽然Vue.js负责的是前端部分，而 SpringBoot+MyBatis+MySQL组成的是后端部分，但MVC模式仍然可以用来理解和组织后端的架构。这里分别解释前端和后端的MVC实现：

后端（SpringBoot+MyBatis+MySQL）：

1. Model（模型）：
   - 在这个上下文中，模型通常指的是Java实体类（Entity）或数据传输对象（DTO）。这些类代表数据库中的表结构，包含了业务数据和相关的属性。
   - MyBatis通过Mapper接口和XML配置文件或者注解来定义SQL操作，这些操作与模型对象交互，从MySQL数据库中获取或更新数据。
2. View（视图）：
   - 在SpringBoot中，视图通常不是直接呈现给用户的HTML，而是由控制器返回的JSON数据。这些数据被前端的Vue.js应用消费，用来渲染用户界面。
   - 视图解析通常通过Spring的模板引擎（如Thymeleaf或Freemarker）或RESTful API来实现。
3. Controller（控制器）：
   - SpringBoot的控制器使用@RestController或@Controller注解的Java类和方法。它们接收来自前端的HTTP请求，调用服务层的方法（这些方法进一步调用MyBatis的Mapper接口），处理业务逻辑，并返回JSON响应给前端。

前端（Vue.js）：

1. Model（模型）：
   - 在Vue.js中，模型指的是Vue实例的数据属性（data）和计算属性（computed properties）。这些属性存储着应用的状态，并且可以被组件内部的逻辑改变。	
2. View（视图）：
   - 视图是Vue组件的实际HTML模板，它们根据模型数据动态渲染。Vue.js使用虚拟DOM（DOM的轻量级表示）来高效地更新视图。
3. Controller（视图模型）：
   - Vue.js中的控制器概念比较弱，通常被称为“组件”（Components）。组件是Vue应用的基本构建块，它们负责处理用户交互、更新模型数据，并响应数据变化来更新视图。

在前后端分离的项目中，前端和后端的MVC模式相互协作，前端通过API请求获取后端的模型数据，然后在前端的视图中展示，而前端的模型更新会触发视图的重新渲染。这种分离使得前端和后端可以独立开发和部署，提高了开发效率和系统的可维护性。

## 数据模型类

### 结果（Result）类

结果类的目的是封装控制器返回的响应数据，包括状态、消息和数据内容。它的作用在于：

1. **统一格式**：结果类定义了统一的数据格式，使得控制器返回的响应在结构上保持一致性，便于客户端进行解析和处理。
2. **清晰明确**：通过结果类，可以清晰地区分响应的状态、消息和数据，使得客户端能够更容易地理解和处理返回的信息。
3. **可扩展性**：结果类可以根据实际需求进行扩展，例如添加额外的字段或元数据，以满足不同场景下的需求变化。
4. **方便处理异常**：结果类也可以用于封装异常信息，并统一返回给客户端，使得异常处理更加统一和规范化。

结果类通常包含三个主要部分：状态（state）、消息（message）和数据（data）。这三部分用于描述请求的处理结果，以便客户端能够清晰地了解返回的信息。

一般来说，结果类的定义如下所示：

```
java复制代码public class Result<T> {
    private int state;       // 状态码
    private String message;  // 消息
    private T data;          // 数据

    // 构造函数、getter和setter方法
}
```

在这个示例中，`Result` 类使用了泛型 `T`，以便可以灵活地定义不同类型的数据。状态码（state）通常用整数表示，用于表示请求处理的结果，比如成功、失败、错误等不同情况对应不同的状态码。消息（message）用于描述请求处理的详细信息，通常是一段文本，可以包含错误信息、提示信息等。数据（data）部分则用于存储请求处理成功后返回的数据，可以是任意类型的对象，根据实际情况定义。

根据具体的业务需求，结果类的定义可能会有所不同，可以根据实际情况添加或修改字段，以满足项目的需求。例如，可以添加额外的元数据字段、错误码字段等，以实现更丰富的功能和更灵活的数据传递。

### 数据传输（DTO）类

DTO（Data Transfer Object）结尾的类是用于数据传输的对象。在软件开发中，DTO 是一种常见的设计模式，用于在不同层之间传输数据，通常用于服务层（Service Layer）和表示层（Presentation Layer）之间的数据传输。

DTO 结尾的类通常具有以下特点和作用：

1. **数据传输**：DTO 类用于在不同的软件组件或系统模块之间传输数据。它们承载着业务实体的数据，并提供给其他模块使用，通常用于服务端和客户端之间、后端和前端之间的数据传递。
2. **数据封装**：DTO 类封装了多个属性，代表了一个完整的数据对象。这些属性可以是业务实体的部分属性，也可以是从多个实体组合而成的新对象。
3. **跨层传输**：由于DTO通常位于不同层之间，它们的设计应该尽可能与特定的业务逻辑无关，而是专注于数据的传输和表示。这样可以保持系统的松耦合性，使得不同层的变化不会影响到彼此。
4. **性能优化**：在某些情况下，DTO 可以用于优化性能，例如减少数据库查询的数据量，只传递客户端需要的部分数据，从而提高系统的响应速度和效率。

总之，DTO 结尾的类用于在不同层之间传输数据，促进系统的解耦和灵活性，同时也有助于提高系统的性能和可维护性。

DTO（Data Transfer Object）通常用在表示层（Presentation Layer）和服务层（Service Layer）之间的代码中。在这两个层级中，DTO 扮演着数据传输的角色，帮助表示层与服务层之间进行数据交换和传递。

1. **在表示层（Presentation Layer）**：DTO 用于表示层的控制器（Controller）或者前端（Frontend）代码中。在这里，DTO 承载着从服务层获取的数据，或者将用户输入的数据传递给服务层。例如，在 Web 应用中，前端页面通过 DTO 对象向后端发送请求，或者接收后端返回的数据。
2. **在服务层（Service Layer）**：DTO 也用于服务层中的服务（Service）或者业务逻辑代码中。在这里，DTO 扮演着传输数据的角色，服务层通过 DTO 对象接收表示层传来的数据，并处理业务逻辑，然后将结果封装成 DTO 对象返回给表示层。服务层中的方法通常接收和返回 DTO 对象，而不是直接操作数据库实体或者其他持久化对象。

因此，DTO 在表示层和服务层之间扮演着数据传输的桥梁，帮助这两个层级之间进行解耦，同时确保数据的传递和处理符合业务逻辑和需求。

```java
// 一个简单的DTO示例，用于在表示层和服务层之间传输用户数据

// UserDTO.java

public class UserDTO {
    private Long id;
    private String username;
    private String email;
    
    // 构造函数、getter和setter方法
    
    public UserDTO(Long id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }
    
    // 省略getter和setter方法...
}

// UserService.java

public interface UserService {
    UserDTO getUserById(Long id);
    void saveUser(UserDTO userDTO);
}

// UserServiceImpl.java

@Service
public class UserServiceImpl implements UserService {
    
    // 注入持久层的UserRepository等
    
    @Override
    public UserDTO getUserById(Long id) {
        // 从持久层获取User实体，然后转换成UserDTO对象返回给表示层
        User user = userRepository.findById(id).orElse(null);
        if (user != null) {
            return new UserDTO(user.getId(), user.getUsername(), user.getEmail());
        }
        return null;
    }
    
    @Override
    public void saveUser(UserDTO userDTO) {
        // 将接收到的UserDTO对象转换成User实体，然后保存到持久层
        User user = new User();
        user.setUsername(userDTO.getUsername());
        user.setEmail(userDTO.getEmail());
        // 设置其他属性...
        userRepository.save(user);
    }
}
```

在这个示例中，`UserDTO` 类被用于表示层和服务层之间传输用户数据。在 `UserService` 接口中定义了获取用户和保存用户的方法，这些方法接收和返回 `UserDTO` 对象。在 `UserServiceImpl` 类中，实现了这些方法，通过DTO对象与持久化实体之间进行数据转换和传输。

### 实体（Entity）类

实体类的作用是代表系统或应用程序中的真实世界对象或概念。以下是它们的作用：

1. **抽象化**：实体类将真实世界的实体抽象成软件系统中可管理和理解的组件。它们封装了与特定实体相关的数据（属性）和行为（方法）。
2. **数据表示**：它们提供了一种结构化的方式来表示和组织数据。每个实体类通常对应于关系数据库中的一张表或NoSQL数据库中的一个文档，从而促进了数据存储、检索和操作。
3. **封装**：实体类封装了相关数据和操作在一个单元内。这种封装通过隐藏实体的内部细节，促进了模块化、可重用性和可维护性。
4. **关系管理**：实体类通常模拟不同实体之间的关系。例如，在电子商务系统中，`Customer` 实体可能与 `Order` 实体具有一对多的关系，其中每个客户可以有多个订单。
5. **业务逻辑实现**：它们封装了与特定实体相关的业务逻辑。这包括验证规则、计算和其他在系统中管理实体行为的操作

## Postman

Postman 是一款功能强大的 API 开发工具，主要功能包括：

1. **发送请求**: 允许用户发送各种类型的 HTTP 请求，如 GET、POST、PUT、DELETE 等，以测试和调试 API。
2. **创建和管理请求集合**: 用户可以将相关请求组织成集合，便于管理和分享。
3. **测试和断言**: 提供了测试脚本的编写和运行功能，可以对请求的响应进行自动化测试，并根据预期结果做出断言。
4. **环境管理**: 允许用户定义不同的环境（如开发、测试、生产环境），并在请求中使用环境变量，方便在不同环境间切换。
5. **自动化集成测试**: 提供了集成测试功能，可以将多个请求组合成测试用例，并自动运行这些测试用例，验证整个 API 的功能和性能。
6. **监视和调试**: 用户可以查看请求和响应的详细信息，包括请求头、响应头、请求体和响应体等，方便调试和排查问题。
7. **Mock 服务器**: 允许用户创建虚拟的 Mock 服务器，模拟 API 的行为，方便前端和后端并行开发。
8. **协作和分享**: 提供了团队协作和分享功能，可以将请求集合和测试用例分享给团队成员，方便协作开发和测试。

### 接口管理

我们对一个或多个系统中的很多用例进行维护，即对用例进行分类管理。如下：

1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）
2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）
3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。

<img src="https://pic2.zhimg.com/v2-f5bd635b77c4e1891f9eb70459228505_r.jpg" alt="img" style="zoom:50%;" />

### 请求接口

![屏幕截图 2024-04-18 095121](C:\Users\richa\Pictures\Screenshots\屏幕截图 2024-04-18 095121.png)

**请求：**

- 请求方法：GET
- 请求URL：http://localhost/index.php?m=Home&c=User&a=do_login&t=0.21942974229794432
- 请求头：Content-Type：XXX
- 请求体：XXX=XXX&YYY=YYY

Postman支持多种请求体类型，具体取决于您的API的需求和配置。以下是常见的请求体类型：

- **Form-Data**: 用于向服务器发送表单数据，通常用于提交表单或文件上传。您可以通过Postman的“Body”选项选择“form-data”类型，并添加键值对参数。
- **x-www-form-urlencoded**: 类似于表单数据，但数据以键值对形式编码在请求的正文中。在Postman中，选择“x-www-form-urlencoded”类型，并添加键值对参数。
- **Raw**: 允许您直接输入原始数据，如JSON、XML或文本。在Postman中选择“Body”，然后选择“raw”类型，并在下拉菜单中选择相应的格式（如JSON）。
- **Binary**: 用于发送二进制数据，例如图像或音频文件。在Postman中，选择“Body”，然后选择“binary”类型，并上传您的文件。
- **GraphQL**: 专门用于发送GraphQL查询。在Postman中，选择“Body”，然后选择“GraphQL”类型，并输入您的GraphQL查询。
- **其他类型**: 根据您的需求，您可能还会遇到其他类型的请求体，如SOAP等。在Postman中，选择适合您需求的类型，并按需设置参数。

您可以根据您的API端点的要求选择适当的请求体类型，并在Postman中相应地设置请求体。

### 响应接口

![img](https://pic2.zhimg.com/80/v2-f857caac945ae316db943d49fb760659_1440w.webp)

**响应：**

- 状态行：Status：200 OK
- 响应头：Headers + Cookies，需要注意的是Cookies是包含在响应头中的，但是为了明显，工具会分开显示
- 响应体：Body

响应体类型通常是根据服务器返回的数据类型而确定的。Postman会根据接收到的响应自动识别响应体类型。以下是一些常见的响应体类型：

- **JSON**: 最常见的响应体类型之一，用于传输结构化数据，例如API响应。
- **XML**: 另一种常见的响应体类型，用于传输标记语言数据，如配置文件或数据交换。
- **HTML**: 用于传输网页内容的响应体类型，通常用于Web应用程序。
- **文本/纯文本**: 用于传输纯文本数据的响应体类型，例如文档或日志文件。
- **二进制数据**: 用于传输图像、音频、视频等二进制数据的响应体类型。
- **其他类型**: 根据服务器返回的数据内容，可能还会有其他自定义的响应体类型。

在Postman中，您可以通过查看响应的“Body”部分来确定响应体类型。Postman通常会根据响应的内容类型自动解析响应体类型，并以适当的方式显示数据。

如果您需要处理特定类型的响应体，例如解析JSON或提取特定的信息，Postman提供了相应的功能和工具来帮助您处理不同类型的响应。

## CAS

CAS（Central Authentication Service）是一个开源的企业级单点登录解决方案，提供了统一的身份认证和授权服务。它的核心思想是将认证服务从应用中独立出来，通过一个单独的认证中心来处理用户的身份验证请求，从而实现多个应用之间的单点登录（SSO）。

以下是 CAS 的一些重要特性和详解：

1. **单点登录（SSO）**：
   - CAS 提供了单点登录功能，用户只需在 CAS 认证中心登录一次，即可在同一域下的所有应用中访问，无需重复登录。
   - 用户登录后，CAS 会颁发一个票据（Ticket），应用可以通过票据向 CAS 验证用户身份。

2. **统一认证管理**：
   - CAS 提供了统一的身份认证和授权管理，将认证逻辑集中到一个独立的认证中心。
   - 开发者可以在 CAS 中配置用户认证方式、授权策略等，实现统一的身份管理。

3. **多种认证方式**：
   - CAS 支持多种认证方式，包括基于用户名密码的表单认证、LDAP 认证、数据库认证等。
   - 开发者可以根据项目需求选择合适的认证方式，并进行相应的配置。

4. **单点登出（SLO）**：
   - CAS 提供了单点登出功能，用户在任一应用注销时，CAS 可以通知其他应用注销当前用户的会话。
   - 这样可以确保用户在整个会话中只需登录一次，提高用户体验。

5. **安全性**：
   - CAS 采用了多种安全机制，包括票据验证、加密传输、防止重放攻击等，保障用户身份和数据的安全性。
   - 开发者可以通过配置加强 CAS 的安全性，确保认证过程的可靠性和安全性。

6. **可扩展性**：
   - CAS 是一个开源项目，提供了丰富的扩展点和定制选项，可以根据需求进行定制和扩展。
   - 开发者可以通过插件、扩展、自定义认证处理器等方式扩展 CAS 的功能和特性。

总的来说，CAS 是一个功能强大、安全可靠的单点登录解决方案，可以帮助企业实现统一的身份认证和授权管理，提高用户体验，简化开发和维护工作。

**使用示例**

使用 CAS 作为 Spring Boot Security 的身份认证方案，需要进行一些配置。以下是一个简单的示例，演示了如何将 CAS 整合到 Spring Boot Security 中：

```
java复制代码import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.cas.ServiceProperties;
import org.springframework.security.cas.authentication.CasAssertionAuthenticationToken;
import org.springframework.security.cas.web.CasAuthenticationEntryPoint;
import org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.authentication.logout.LogoutFilter;
import org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll() // 允许访问公开资源
                .anyRequest().authenticated() // 其他请求需要认证
                .and()
            .logout()
                .logoutUrl("/logout") // 登出路径
                .permitAll() // 登出不需要认证
                .and()
            .addFilterBefore(casLogoutFilter(), LogoutFilter.class)
            .exceptionHandling()
                .authenticationEntryPoint(casAuthenticationEntryPoint());
    }

    @Bean
    public CasAuthenticationEntryPoint casAuthenticationEntryPoint() {
        CasAuthenticationEntryPoint entryPoint = new CasAuthenticationEntryPoint();
        entryPoint.setLoginUrl("https://your-cas-server.com/login");
        entryPoint.setServiceProperties(serviceProperties());
        return entryPoint;
    }

    @Bean
    public ServiceProperties serviceProperties() {
        ServiceProperties serviceProperties = new ServiceProperties();
        serviceProperties.setService("https://your-application.com/login/cas");
        serviceProperties.setSendRenew(false);
        return serviceProperties;
    }

    @Bean
    public CasLogoutFilter casLogoutFilter() {
        CasLogoutFilter filter = new CasLogoutFilter("https://your-cas-server.com/logout");
        filter.setLogoutRequestMatcher(new AntPathRequestMatcher("/logout"));
        filter.setLogoutSuccessUrl("/logged-out");
        filter.setFilterProcessesUrl("/logout");
        filter.setServiceProperties(serviceProperties());
        return filter;
    }
}
```

上述配置示例中，假设 CAS 服务器位于 "[https://your-cas-server.com](https://your-cas-server.com/)"，而你的应用位于 "[https://your-application.com](https://your-application.com/)"。你需要将这些 URL 替换为实际的 CAS 服务器和应用程序的 URL。

这个配置示例演示了如何配置 CAS 认证入口点、服务属性以及 CAS 登出过滤器。请根据实际情况进行相应的修改和配置。

同时，你需要在 Spring Boot 项目的配置文件中配置 CAS 服务器的地址、CAS 客户端的信息等相关信息。

### CaSSOFilter

`CasSSOFilter` 过滤器是 CAS（Central Authentication Service）单点登录系统中的一个重要组成部分，用于处理单点登录相关的功能。它的主要作用是拦截用户的登录请求，将其重定向到 CAS 服务器进行统一认证，并处理 CAS 服务器返回的认证结果，最终完成用户在当前系统的登录操作。

具体运用包括：

1. **用户认证**：当用户在系统中进行登录时，`CasSSOFilter` 拦截登录请求，并将用户重定向到 CAS 服务器进行认证。CAS 服务器验证用户身份后，会返回认证成功或失败的结果。

2. **处理认证结果**：根据 CAS 服务器返回的认证结果，`CasSSOFilter` 负责处理用户的登录状态。如果认证成功，用户将被授权访问系统资源；如果认证失败，可能会要求用户重新进行登录或给出相应的错误提示。

3. **单点登录**：通过 CAS 协议，`CasSSOFilter` 实现了单点登录的功能。用户在一个系统中进行登录后，可以在其他系统中自动完成登录，无需重复输入用户名和密码。

4. **会话管理**：`CasSSOFilter` 可能会涉及到会话管理的功能，例如在用户登录成功后，创建或更新用户的会话信息，以及在用户注销时清理会话数据等。

5. **权限控制**：在认证成功后，`CasSSOFilter` 可能会根据用户的权限配置，决定用户能够访问的资源范围，从而实现权限控制的功能。

总的来说，`CasSSOFilter` 运用于 CAS 单点登录系统中，负责拦截用户的登录请求，与 CAS 服务器进行认证交互，并根据认证结果处理用户的登录状态，从而实现单点登录和统一认证的功能。

### SingleSignOutHttpSessionListener

`SingleSignOutHttpSessionListener` 是 CAS（Central Authentication Service）单点登录系统中的一个监听器，用于监听用户会话的销毁事件，从而实现单点登出功能。

具体作用包括：

1. **监听会话销毁事件**：`SingleSignOutHttpSessionListener` 监听用户会话销毁事件，即用户在任意一个系统中注销登录时触发的事件。

2. **发送单点登出请求**：当用户在某个系统中注销登录时，该监听器会收到会话销毁事件，并向 CAS 服务器发送单点登出请求，通知 CAS 服务器注销该用户在其他相关系统中的登录状态。

3. **实现单点登出**：CAS 服务器收到单点登出请求后，会立即注销用户在其他相关系统中的登录状态，从而实现用户在整个系统中的单点登出。

4. **保障安全性**：单点登出功能有助于保障系统的安全性，确保用户在注销登录后不能再访问系统中的受保护资源，从而减少安全风险。

5. **提升用户体验**：单点登出功能简化了用户的操作流程，用户只需要在一个系统中进行注销操作，就能够在所有相关系统中完成退出登录，提升了用户的体验和便利性。

总的来说，`SingleSignOutHttpSessionListener` 的作用是监听用户会话的销毁事件，实现单点登出功能，保障系统的安全性并提升用户体验。

### **Ticket Granting Ticket (TGT)**

TGT 是 CAS 中的一个重要概念，用于表示用户在 CAS 服务器上的登录凭证。用户在第一次登录时，CAS 服务器会颁发一个 TGT，然后使用 TGT 来获取服务票据（Service Ticket）进行单点登录。

### **Service Ticket (ST)**

ST 是 CAS 中的另一个重要概念，用于表示用户访问特定服务的令牌。用户在获得 TGT 后，可以使用 TGT 来向 CAS 服务器请求 ST，然后使用 ST 来访问受保护的服务。