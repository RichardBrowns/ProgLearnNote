# 开发理论

## 分布式理论

# 设计模式

## 创建型 - 单例模式（Singleton pattern）

单例模式（Singleton Pattern）是一种常用的设计模式，它保证一个类在整个应用程序中只实例化一次，并为整个应用提供一个全局访问点。这种模式常用于那些需要频繁实例化然后销毁的对象，或者创建对象需要消耗大量资源的情况，通过单例可以减少系统开销，提升性能。

**特点**

- **确保唯一性**：在任何情况下，类的实例都只有一个。
- **全局访问点**：提供一个全局访问的方法，让其他对象能够获取这个唯一的实例。
- **延迟初始化**：单例的实例通常直到第一次使用时才被创建，这称为懒汉式单例；也可以在类加载时就创建，这称为饿汉式单例。

**实现方式**

**饿汉式（静态常量）**

适用于类加载时就需要初始化的情况，线程安全。

```java
public class Singleton {
    private final static Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```

**懒汉式（线程不安全）**

基本的懒汉式实现不是线程安全的，不推荐直接使用。

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**双重检查锁定（DCL, Double-Checked Locking）**

一种常用的线程安全懒汉式实现方式，既保证了线程安全，又实现了延迟加载。

```java
public class Singleton {
    private volatile static Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

**静态内部类**

利用Java类加载机制保证线程安全，也是懒汉式的一种高效实现。

```java
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**适用场景**

- 配置管理器，如数据库配置、线程池等，只需要一个实例来管理这些资源。
- 日志记录器，通常一个应用只需要一个日志输出源。
- 线程池、缓存、对话框、注册表设置、设备管理器等。

**注意事项**

- 单例模式可能会隐藏类的实例的依赖关系，使得测试变得更加困难。
- 在多线程环境下，确保单例的正确实现是关键，避免多例或线程安全问题。
- 考虑到序列化和反序列化可能破坏单例，需要在单例类中添加相应的readResolve方法来处理。

## 创建型 - 工厂模式（Factory）

工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种创建对象的最佳方式，即不在客户端中直接实例化对象，而是通过工厂类来决定实例化哪一个产品类。这样做可以**将对象的创建过程与具体的使用过程分离**，降低代码间的耦合度，提高系统的灵活性和可扩展性。

**工厂模式的类型**

工厂模式主要有三种类型：

1. **简单工厂（Simple Factory）**
   - 一个工厂类根据传入的参数，决定创建出哪一种产品类的实例。
   - 优点：简单易用，减少了客户端与具体产品的耦合。
   - 缺点：不符合开闭原则，增加新产品时需要修改工厂类代码。
2. **工厂方法（Factory Method）**
   - 定义一个用于创建对象的接口，但由子类决定实例化哪一个类。
   - 工厂方法使一个类的实例化延迟到其子类。
   - 优点：符合开闭原则，增加新产品时只需要添加新的工厂子类即可。
   - 缺点：每新增一个产品都需要对应的新工厂类，类的数量成对增加。
3. **抽象工厂（Abstract Factory）**
   - 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
   - 适用于有多个产品族，每个族内有多个产品的情况。
   - 优点：可以应对更复杂的对象创建需求，保持系统的高内聚性。
   - 缺点：增加了系统的抽象性和理解难度。

**示例代码（Java）**

**简单工厂**

```java
// 产品接口
interface Product {
    void show();
}

// 具体产品A
class ConcreteProductA implements Product {
    public void show() {
        System.out.println("ConcreteProductA");
    }
}

// 具体产品B
class ConcreteProductB implements Product {
    public void show() {
        System.out.println("ConcreteProductB");
    }
}

// 简单工厂
class SimpleFactory {
    public static Product createProduct(String type) {
        if ("A".equals(type)) {
            return new ConcreteProductA();
        } else if ("B".equals(type)) {
            return new ConcreteProductB();
        }
        throw new IllegalArgumentException("Invalid type");
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        Product productA = SimpleFactory.createProduct("A");
        productA.show();
        
        Product productB = SimpleFactory.createProduct("B");
        productB.show();
    }
}
```

**适用场景**

- 当一个类不知道它所必须创建的对象的类时。
- 当一个类希望由它的子类来指定它所创建的对象时。
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪个帮助子类是代理者这一信息局部化的时候。

**注意事项**

- 工厂模式的选择取决于项目的需求，简单工厂适用于产品较少的情况，而工厂方法和抽象工厂则提供了更好的扩展性和灵活性。
- 过度使用工厂模式可能导致系统结构复杂化，应根据实际情况权衡利弊。

## 创建型 - 建造者模式（Builder）

Builder模式，也被称为建造者模式，是一种创建型设计模式。它旨在将一个**复杂对象**的构建过程与它的表示分离，使得同样的构建过程可以创建不同的表示。这样做的目的是为了提高代码的灵活性和可读性，同时**避免构造函数或工厂方法因参数过多而变得难以理解和使用。**

**模式结构**

- **Product（产品类）**：Builder模式的最终产物，包含多个组成部件。
- **Builder（抽象建造者）**：定义了创建Product对象的各个部件的接口，通常包含多个buildPartX()方法用于构建每个部件，还有一个getProduct()方法用于返回最后组装完成的产品。
- **ConcreteBuilder（具体建造者）**：实现Builder接口，负责实际构建和装配各个部件。
- **Director（指挥者）**：负责调用Builder中的方法来创建Product对象。导演类隔离了客户端与建造过程，使得客户端不必知道产品是如何被创建和组装的。

**适用场景**

1. 当创建复杂对象时，其构造过程允许通过子类定制。
2. 构造过程必须允许被构造的对象有不同的表示。
3. 需要控制产品的生成过程，以避免构造函数中庞大的参数列表。

**优点**

- 提高了代码的可读性和可维护性，尤其是当构造过程复杂时。
- 建造者独立，易于扩展新的Builder来创建不同变体的产品。
- 封装性好，用户只需关注Director的构建过程，无需了解内部的具体构建细节。

**示例代码（Java）**

```java
// 产品类
class Product {
    private String partA;
    private String partB;

    // getters and setters...

    @Override
    public String toString() {
        return "Product [partA=" + partA + ", partB=" + partB + "]";
    }
}

// 抽象建造者
interface Builder {
    void buildPartA();
    void buildPartB();
    Product getProduct();
}

// 具体建造者
class ConcreteBuilder implements Builder {
    private Product product = new Product();

    @Override
    public void buildPartA() {
        product.setPartA("Part A");
    }

    @Override
    public void buildPartB() {
        product.setPartB("Part B");
    }

    @Override
    public Product getProduct() {
        return product;
    }
}

// 指挥者
class Director {
    public void construct(Builder builder) {
        builder.buildPartA();
        builder.buildPartB();
    }
}

// 客户端代码
public class BuilderPatternDemo {
    public static void main(String[] args) {
        Director director = new Director();
        Builder builder = new ConcreteBuilder();
        
        director.construct(builder);
        Product product = builder.getProduct();
        System.out.println(product);
    }
}
```



