

# 开发理论

## 分布式理论

# 设计模式

## 创建型 - 单例模式（Singleton pattern）

单例模式（Singleton Pattern）是一种常用的设计模式，它保证一个类在整个应用程序中只实例化一次，并为整个应用提供一个全局访问点。这种模式常用于那些需要频繁实例化然后销毁的对象，或者创建对象需要消耗大量资源的情况，通过单例可以减少系统开销，提升性能。

**特点**

- **确保唯一性**：在任何情况下，类的实例都只有一个。
- **全局访问点**：提供一个全局访问的方法，让其他对象能够获取这个唯一的实例。
- **延迟初始化**：单例的实例通常直到第一次使用时才被创建，这称为懒汉式单例；也可以在类加载时就创建，这称为饿汉式单例。

**实现方式**

**饿汉式（静态常量）**

适用于类加载时就需要初始化的情况，线程安全。

```java
public class Singleton {
    private final static Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```

**懒汉式（线程不安全）**

基本的懒汉式实现不是线程安全的，不推荐直接使用。

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**双重检查锁定（DCL, Double-Checked Locking）**

一种常用的线程安全懒汉式实现方式，既保证了线程安全，又实现了延迟加载。

```java
public class Singleton {
    private volatile static Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

**静态内部类**

利用Java类加载机制保证线程安全，也是懒汉式的一种高效实现。

```java
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**适用场景**

- 配置管理器，如数据库配置、线程池等，只需要一个实例来管理这些资源。
- 日志记录器，通常一个应用只需要一个日志输出源。
- 线程池、缓存、对话框、注册表设置、设备管理器等。

**注意事项**

- 单例模式可能会隐藏类的实例的依赖关系，使得测试变得更加困难。
- 在多线程环境下，确保单例的正确实现是关键，避免多例或线程安全问题。
- 考虑到序列化和反序列化可能破坏单例，需要在单例类中添加相应的readResolve方法来处理。

## 创建型 - 工厂模式（Factory）

工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种创建对象的最佳方式，即不在客户端中直接实例化对象，而是通过工厂类来决定实例化哪一个产品类。这样做可以**将对象的创建过程与具体的使用过程分离**，降低代码间的耦合度，提高系统的灵活性和可扩展性。

**工厂模式的类型**

工厂模式主要有三种类型：

1. **简单工厂（Simple Factory）**
   - 一个工厂类根据传入的参数，决定创建出哪一种产品类的实例。
   - 优点：简单易用，减少了客户端与具体产品的耦合。
   - 缺点：不符合开闭原则，增加新产品时需要修改工厂类代码。
2. **工厂方法（Factory Method）**
   - 定义一个用于创建对象的接口，但由子类决定实例化哪一个类。
   - 工厂方法使一个类的实例化延迟到其子类。
   - 优点：符合开闭原则，增加新产品时只需要添加新的工厂子类即可。
   - 缺点：每新增一个产品都需要对应的新工厂类，类的数量成对增加。
3. **抽象工厂（Abstract Factory）**
   - 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
   - 适用于有多个产品族，每个族内有多个产品的情况。
   - 优点：可以应对更复杂的对象创建需求，保持系统的高内聚性。
   - 缺点：增加了系统的抽象性和理解难度。

**示例代码（Java）**

**简单工厂**

```java
// 产品接口
interface Product {
    void show();
}

// 具体产品A
class ConcreteProductA implements Product {
    public void show() {
        System.out.println("ConcreteProductA");
    }
}

// 具体产品B
class ConcreteProductB implements Product {
    public void show() {
        System.out.println("ConcreteProductB");
    }
}

// 简单工厂
class SimpleFactory {
    public static Product createProduct(String type) {
        if ("A".equals(type)) {
            return new ConcreteProductA();
        } else if ("B".equals(type)) {
            return new ConcreteProductB();
        }
        throw new IllegalArgumentException("Invalid type");
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        Product productA = SimpleFactory.createProduct("A");
        productA.show();
        
        Product productB = SimpleFactory.createProduct("B");
        productB.show();
    }
}
```

**适用场景**

- 当一个类不知道它所必须创建的对象的类时。
- 当一个类希望由它的子类来指定它所创建的对象时。
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪个帮助子类是代理者这一信息局部化的时候。

**注意事项**

- 工厂模式的选择取决于项目的需求，简单工厂适用于产品较少的情况，而工厂方法和抽象工厂则提供了更好的扩展性和灵活性。
- 过度使用工厂模式可能导致系统结构复杂化，应根据实际情况权衡利弊。

## 创建型 - 建造者模式（Builder）

Builder模式，也被称为建造者模式，是一种创建型设计模式。它旨在将一个**复杂对象**的构建过程与它的表示分离，使得同样的构建过程可以创建不同的表示。这样做的目的是为了提高代码的灵活性和可读性，同时**避免构造函数或工厂方法因参数过多而变得难以理解和使用。**

**模式结构**

- **Product（产品类）**：Builder模式的最终产物，包含多个组成部件。
- **Builder（抽象建造者）**：定义了创建Product对象的各个部件的接口，通常包含多个buildPartX()方法用于构建每个部件，还有一个getProduct()方法用于返回最后组装完成的产品。
- **ConcreteBuilder（具体建造者）**：实现Builder接口，负责实际构建和装配各个部件。
- **Director（指挥者）**：负责调用Builder中的方法来创建Product对象。导演类隔离了客户端与建造过程，使得客户端不必知道产品是如何被创建和组装的。

**适用场景**

1. 当创建复杂对象时，其构造过程允许通过子类定制。
2. 构造过程必须允许被构造的对象有不同的表示。
3. 需要控制产品的生成过程，以避免构造函数中庞大的参数列表。

**优点**

- 提高了代码的可读性和可维护性，尤其是当构造过程复杂时。
- 建造者独立，易于扩展新的Builder来创建不同变体的产品。
- 封装性好，用户只需关注Director的构建过程，无需了解内部的具体构建细节。

**示例代码（Java）**

```java
// 产品类
class Product {
    private String partA;
    private String partB;

    // getters and setters...

    @Override
    public String toString() {
        return "Product [partA=" + partA + ", partB=" + partB + "]";
    }
}

// 抽象建造者
interface Builder {
    void buildPartA();
    void buildPartB();
    Product getProduct();
}

// 具体建造者
class ConcreteBuilder implements Builder {
    private Product product = new Product();

    @Override
    public void buildPartA() {
        product.setPartA("Part A");
    }

    @Override
    public void buildPartB() {
        product.setPartB("Part B");
    }

    @Override
    public Product getProduct() {
        return product;
    }
}

// 指挥者
class Director {
    public void construct(Builder builder) {
        builder.buildPartA();
        builder.buildPartB();
    }
}

// 客户端代码
public class BuilderPatternDemo {
    public static void main(String[] args) {
        Director director = new Director();
        Builder builder = new ConcreteBuilder();
        
        director.construct(builder);
        Product product = builder.getProduct();
        System.out.println(product);
    }
}
```

## 结构型 - 装饰者模式（Decorator）

## 结构型 - 代理模式（Proxy）

# 网络协议

网络协议是计算机网络中各个对等实体（如计算机、路由器等）之间进行有效数据交换所遵循的一系列规则、标准和约定的集合。这些协议确保了不同设备间能够顺利沟通，即使它们可能采用不同的操作系统、硬件架构或编程语言。

网络协议通常按照层次结构组织，每一层都为上一层提供服务，同时依赖下一层的功能。最著名的模型是OSI七层模型（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）和TCP/IP四层模型（网络接口层、网络层、传输层、应用层）。

常见的网络协议包括：

- TCP/IP (Transmission Control Protocol/Internet Protocol)：互联网的基础协议，负责数据的可靠传输和地址路由。
- HTTP/HTTPS (Hypertext Transfer Protocol/Secure)：用于网页浏览，HTTPS为其加密版本。
- FTP (File Transfer Protocol)：文件传输协议，用于在网络上进行文件上传和下载。
- SMTP (Simple Mail Transfer Protocol)：电子邮件传输协议。
- UDP (User Datagram Protocol)：提供无连接的数据报服务，适用于对速度要求高而不需要可靠传输的场景。
- DHCP (Dynamic Host Configuration Protocol)：自动分配IP地址等网络配置信息给网络设备。

通过遵循这些协议，全球范围内的设备和网络能够相互通信，共享资源和服务。

## HTTP（超文本传输协议）

HTTP（Hypertext Transfer Protocol，超文本传输协议）是一种应用层协议，用于从Web服务器传输超文本信息到本地浏览器的传输协议。

### 基础概念

**URI**

URI（Uniform Resource Identifier）是统一资源标识符，它是一种标准格式，用于唯一地标识互联网上的资源。这个标识符可以是网络上的任何实体，如网页、图像、视频、服务或其他数据。URI是URL（Uniform Resource Locator，统一资源定位符）和URN（Uniform Resource Name，统一资源名称）的超集。
下面是URI的一些关键概念和特点：

1. 唯一性：每个URI都是唯一的，确保了资源的明确标识。

2. 结构：URI通常由几个组件组成，包括：

   - 方案（Scheme）：定义了如何解析和访问资源的协议，如http://、https://、ftp://等。
   - 授权（Authority）：包含访问资源所需的权限信息，如用户名、密码（虽然现在不推荐使用）、主机名和端口号。
   - 路径（Path）：指定了资源在服务器上的位置。
   - 查询（Query）：可选的，包含以问号（?）开头的参数，用于传递额外的信息。
   - 片段（Fragment）：可选的，以井号（#）开头，用于标识文档内部的特定部分。

   一个完整的URI示例：https://www.example.com/path/to/page?query=param#fragment

3. URL和URN：

   - URL：是URI的一个子集，提供了资源的具体位置信息，可以用来访问资源。
   - URN：是URI的另一种形式，它提供了资源的唯一名称，而不指示其位置。URN旨在长期不变，即使资源的实际位置或表示方式发生变化。

4. 使用：URI在Web开发中广泛使用，例如在HTML链接、图像源、脚本引用等处，以及在HTTP请求中指定要访问的资源。

5. 编码：URI中的非ASCII字符通常需要使用百分比编码（%）进行转义，以确保在不同系统间的兼容性。

6. 标准化：URI的设计遵循了国际标准，如RFC 3986，以确保跨平台和跨应用的一致性。

URI是互联网架构的核心部分，它使得资源的发现、引用和访问成为可能，从而促进了全球信息的交换。

**HTTP请求报文**

![img](https://pdai.tech/images/pics/HTTP_RequestMessageExample.png)

1. **请求行（Request Line）**：包含了请求方法、请求的URL和HTTP协议的版本。例如：`GET /index.html HTTP/1.1`，表示使用GET方法请求`/index.html`资源，使用HTTP/1.1版本的协议。
2. **请求头部（Request Headers）**：包含了请求的一些元数据信息，如`Host`、`User-Agent`、`Content-Type`等，用于描述客户端的一些信息和请求的属性。
3. **空行**：请求头部和请求体之间有一个空行作为分隔符。
4. **请求体（Request Body）**：对于POST请求等带有实体内容的请求，请求体包含了客户端发送的数据。

**HTTP响应报文**

![img](https://pdai.tech/images/pics/HTTP_ResponseMessageExample.png)

1. **状态行（Status Line）**：包含了HTTP协议的版本、状态码和状态消息。例如：`HTTP/1.1 200 OK`，表示使用HTTP/1.1版本的协议，状态码为200，状态消息为OK。
2. **响应头部（Response Headers）**：包含了响应的一些元数据信息，如`Content-Type`、`Content-Length`等，用于描述服务器的一些信息和响应的属性。
3. **空行**：响应头部和响应体之间有一个空行作为分隔符。
4. **响应体（Response Body）**：对于GET请求等带有实体内容的响应，响应体包含了服务器返回的数据。

这些部分共同构成了HTTP请求和响应的包，每个部分都承载着不同的信息和功能，用于描述请求的属性和内容，以及服务器的响应和返回的数据。

### 工作流程

1. **建立连接**：客户端通过TCP三次握手与服务器建立连接，通常默认端口为80（HTTP）或443（HTTPS）。
2. **发送请求**：客户端发送HTTP请求到服务器
3. **服务器处理请求**：服务器接收到请求后，根据请求内容处理并准备响应
4. **发送响应**：服务器将响应发送回客户端
5. **关闭连接**：在HTTP/1.0中，每次请求响应后都会关闭连接；而在HTTP/1.1及之后，可以保持连接以复用

### 请求方法

HTTP请求方法可以根据其语义和用途进行分类，常见的HTTP请求方法包括：

1. **GET**：用于请求指定的资源，通常用于获取数据。GET请求不会修改服务器上的资源，而是只会获取资源的副本。
2. **POST**：向指定资源提交数据，用于在服务器上创建新的资源。POST请求可能会导致服务器的状态发生变化或副作用。
3. **PUT**：用于向指定资源位置上传新的内容，用上传的内容替换指定的资源。PUT请求是幂等的，即多次调用相同的PUT请求，结果应该是相同的。
4. **DELETE**：请求服务器删除指定的资源。
5. **HEAD**：类似于GET请求，但服务器只返回响应头部，不会返回实际的资源内容。主要用于获取资源的元数据，如大小、类型等。
6. **OPTIONS**：用于获取目的资源所支持的通信选项。
7. **PATCH**：用于对资源进行局部更新，只对资源的部分内容进行修改。
8. **TRACE**：用于测试目的，向服务器发送一个请求，并在响应中返回服务器收到的原始请求内容，主要用于诊断。

这些是HTTP协议中常见的请求方法，每种方法都有特定的语义和用途，用于在客户端和服务器之间进行不同类型的交互。

### 状态码

HTTP状态码是HTTP协议中服务器用来向客户端（通常是Web浏览器）报告请求处理结果的三位数字代码。这些代码提供了关于请求是否成功、遇到了什么问题以及如何解决的信息。HTTP状态码被分为五个主要类别，每个类别都以第一位数字来区分：

1. 1xx（信息性状态码）： 

   这些临时响应表明服务器已经收到了请求，并且继续处理。它们通常不会被缓存，例如100 Continue，表示客户端可以继续发送请求的主体部分。

2. 2xx（成功状态码）：

   表示请求已被成功处理。最常见的状态码是200 OK，意味着请求已完成，且服务器返回了请求的资源。

3. 3xx（重定向状态码）：

    这些状态码表示客户端需要采取额外的步骤来完成请求。例如：

   - 301 Moved Permanently：请求的资源已被永久移动到新的URL。
   - 302 Found：临时重定向，资源的位置发生了变化。
   - 304 Not Modified：如果客户端有资源的缓存副本，且资源未更新，服务器返回此状态码，指示客户端可以直接使用缓存。

4. 4xx（客户端错误状态码）： 

   这类状态码表示请求中存在错误，问题出在客户端。例如：

   - 400 Bad Request：服务器无法理解请求。
   - 401 Unauthorized：请求需要用户认证。
   - 403 Forbidden：服务器理解请求，但拒绝执行。
   - 404 Not Found：请求的资源在服务器上未找到。

5. 5xx（服务器错误状态码）： 

   这些状态码表示服务器在处理请求时遇到错误。例如：

   - 500 Internal Server Error：服务器遇到了意外情况，无法完成请求。
   - 503 Service Unavailable：服务器暂时无法处理请求，可能是过载或维护。

每个状态码后面还可能有一个简短的描述，例如“OK”、“Moved Permanently”等，帮助理解具体情况。正确理解和处理这些状态码对于Web开发、故障排查和用户体验优化至关重要。

### 头部

HTTP头部（HTTP Headers）是HTTP协议中的一部分，它们包含在HTTP请求和响应消息中，用来提供额外的元信息，这些信息用于描述请求或响应的性质，以及客户端和服务器之间的交互细节。HTTP头部由键值对组成，键是头部字段名，值是相关数据。以下是一些常见的HTTP头部及其用途：

1. 请求头（Request Headers）：
   - Host: 指定请求的服务器地址和端口号，用于虚拟主机设置。
   - User-Agent: 描述发起请求的客户端（浏览器）信息，包括浏览器类型、版本和操作系统。
   - Accept: 客户端可以接受的媒体类型，如文本、图像、视频等。
   - Accept-Language: 客户端偏好语言。
   - Authorization: 提供身份验证信息，如Basic Auth或Bearer Token。
   - Cookie: 包含服务器发送给客户端的cookie信息，用于会话管理。
2. 响应头（Response Headers）：
   - Content-Type: 指定响应体的数据类型，如text/html、application/json等。
   - Server: 服务器应用程序的名称和版本。
   - Location: 在3xx响应中，指示客户端应重定向到的URL。
   - Set-Cookie: 服务器设置的cookie信息，用于在客户端存储状态。
   - Cache-Control: 控制缓存行为，如no-cache、max-age等。
   - Content-Length: 响应体的大小，以字节为单位。
3. 实体头（Entity Headers）：
   - Content-Length: 实体（如请求体或响应体）的长度。
   - Content-Encoding: 实体使用的编码，如gzip、deflate等。
   - Content-Disposition: 描述附件的处理方式，如attachment表示下载。
   - Last-Modified: 资源的最后修改时间，用于缓存验证。
4. 通用头（General Headers）：
   - Date: 消息产生的日期和时间。
   - Connection: 控制连接的行为，如Keep-Alive表示保持连接。
   - Pragma: 用于包含指令，如Pragma: no-cache用于强制不使用缓存。
   - Upgrade: 请求升级到另一协议，如从HTTP升级到WebSocket。
5. 安全和隐私相关的头：
   - Content-Security-Policy: 控制浏览器加载资源的安全策略。
   - X-XSS-Protection: 防止跨站脚本攻击的保护机制。
   - X-Frame-Options: 防止点击劫持，限制谁可以嵌入页面。
   - Strict-Transport-Security: 强制使用HTTPS，提高安全性。

HTTP头部允许客户端和服务器之间交换关于请求和响应的附加信息，这些信息对于正确处理请求、提供个性化服务、实现缓存、认证和安全等方面至关重要。

### Cookie

HTTP Cookie 是一种用于在客户端和服务器之间持久存储信息的技术，主要用于跟踪用户会话、个性化网站内容、记录用户偏好等。以下是关于HTTP Cookie的详解：

1. 创建与设置：
   - Set-Cookie: 服务器通过HTTP响应头Set-Cookie来设置Cookie。服务器发送一个包含Set-Cookie的响应，指定Cookie的名称、值、过期时间、路径、域、安全属性等。
   - 客户端存储：浏览器收到Set-Cookie指令后，会将Cookie存储在本地，通常是作为文本文件。
2. 发送与读取：
   - Cookie 请求头: 当客户端（浏览器）发起HTTP请求时，它会在请求头中包含Cookie字段，将所有相关Cookie的名称和值发送回服务器。
   - 服务器读取：服务器通过读取请求头中的Cookie字段来获取客户端的Cookie信息。
3. 生命周期与过期：
   - 生命周期：Cookie可以通过Set-Cookie指令中的Max-Age或Expires属性设置生命周期。若无明确设置，Cookie通常在浏览器会话结束时（如关闭浏览器窗口）删除。
   - 过期：Expires属性指定了绝对日期和时间，而Max-Age则指定了相对秒数。
4. 安全性与隐私：
   - Secure：设置此属性的Cookie只能通过HTTPS传输，增加了安全性。
   - HttpOnly：此属性防止JavaScript访问Cookie，有助于防止跨站脚本攻击（XSS）。
5. 同源策略：
   - Cookie遵循同源策略，即只能被同一域名下的页面访问。这意味着一个网站的Cookie不能被其他网站读取。
6. Cookie分类：
   - 会话Cookie：没有Expires或Max-Age属性，只存在于浏览器会话期间，关闭浏览器就会消失。
   - 持久化Cookie：有Expires或Max-Age属性，会在设定的时间内保留在用户的硬盘上。
7. 限制与管理：
   - 数量限制：每个域名下的Cookie数量有限制，一般在20个左右。
   - 大小限制：单个Cookie的大小通常限制在4KB左右。
   - 用户控制：用户可以通过浏览器设置来管理Cookie，包括接受哪些Cookie、清除Cookie等。
8. 应用场景：
   - 用户认证：登录成功后，服务器设置一个Session ID的Cookie，后续请求携带此Cookie证明用户已登录。
   - 个性化：记录用户偏好，如语言设置、主题选择等。
   - 购物车功能：保存用户添加到购物车的商品信息。
   - 广告追踪：一些广告网络使用Cookie来跟踪用户行为，以便提供针对性的广告。

### Session

HTTP Session是Web应用程序中用于跟踪用户状态的一种机制，由于HTTP协议本身是无状态的，即服务器不保留与客户端之间交互的任何信息，因此引入Session来维护用户会话状态。以下是HTTP Session的详细说明：

1. 概念： 
   - HTTP Session是在服务器端创建的，用于存储特定用户会话所需的信息。每个用户会话都有一个唯一的标识符，即Session ID，用来区分不同的用户会话。
2. 创建过程：
   - 当用户首次访问某个需要会话管理的Web应用时，服务器会为该用户创建一个新的Session，并生成一个唯一的Session ID。
   - Session ID通常通过Cookie（名为JSESSIONID是最常见的形式，但名称可配置）发送给客户端浏览器。如果客户端禁用了Cookie，则可以通过URL重写（在每个链接和表单中添加Session ID）来传递Session ID。
3. 存储信息：
   - 服务器端使用内存（或者配合数据库、文件系统等持久化存储）来保存Session数据，这些数据可以是用户身份、购物车内容、用户偏好等任何需要跨请求保持的信息。
4. 识别用户：
   - 用户每次向服务器发送请求时，浏览器会自动附带之前设置的Session ID（通过Cookie或URL重写）。服务器根据这个ID找到对应的Session数据，从而识别用户并提供个性化的响应。
5. 生命周期管理：
   - 有效期：Session有生命周期，可以通过配置设置Session的超时时间，一旦超过这个时间未有新的请求，服务器会自动销毁该Session。
   - 手动销毁：开发人员也可以通过调用HttpSession.invalidate()方法主动销毁Session。
6. 安全性考虑：
   - 保护Session ID的安全非常重要，因为它是访问用户会话的钥匙。应使用HTTPS来加密Session ID的传输，避免中间人攻击。
   - 定期更换Session ID，防止会话固定攻击。
   - 监控和限制Session的数量，避免资源耗尽攻击。
7. 跨域问题：
   - 默认情况下，Session ID在不同的子域名间不共享。如果需要跨域共享Session，可以通过设置Cookie的Domain属性来实现。
8. 性能考量：
   - 由于Session数据存储在服务器端，大量用户同时在线时可能会消耗较多服务器资源。因此，合理设计Session数据的存储策略（如使用Redis、Memcached等分布式缓存）是优化性能的关键。

综上所述，HTTP Session为无状态的HTTP协议提供了一种维护用户状态的有效手段，是构建动态、交互式Web应用的基础。

### 缓存

HTTP缓存机制是HTTP协议中用于提高网页和网络资源加载速度的重要策略。它通过在客户端（通常是浏览器）存储从服务器获取的资源副本，使得在后续请求相同资源时可以直接使用本地副本，无需再次向服务器发起请求。这减少了网络延迟和带宽使用，加快了页面加载速度。以下是HTTP缓存机制的关键组成部分：

**缓存控制策略**

1. 缓存控制头字段：
   - Cache-Control: 服务器通过此字段告知客户端如何缓存资源。例如，max-age=<seconds>指定资源在多少秒内可以被缓存并重用，no-cache要求每次请求都向服务器验证资源是否更新。
   - Pragma: 对于HTTP/1.0兼容性，使用Pragma: no-cache与Cache-Control: no-cache类似，指示不应使用缓存副本。
2. ** Expires**:
   - 一个过时但仍然被支持的字段，用于指定资源何时变为过期，之后需要重新验证或获取。日期格式为GMT。
3. ETag (Entity Tag):
   - 服务器为每个资源分配一个唯一的标识符（ETag）。客户端在请求时会发送If-None-Match头，包含上次获取资源的ETag。如果ETag匹配，服务器返回304 Not Modified，表示资源未改变，可以使用缓存副本。
4. Last-Modified:
   - 服务器在响应中包含资源的最后修改时间。客户端在后续请求中通过If-Modified-Since头携带这个时间。如果资源未修改，服务器返回304 Not Modified。

**缓存验证**

当缓存资源达到其最大年龄或有其他原因需要验证时，客户端会发送验证请求到服务器，而不是整个资源。使用ETag或Last-Modified进行验证可以减少不必要的数据传输。

**缓存类型**

1. 强缓存（Fresh Cache）:
   - 客户端直接使用本地缓存，无需与服务器交互。由Cache-Control的max-age或Expires控制。
2. 协商缓存（Validation Cache）:
   - 客户端使用本地缓存，但需向服务器验证其有效性。使用ETag或Last-Modified进行验证。

**用户行为与缓存**

1. 用户刷新页面（F5）或使用浏览器的刷新功能时，某些浏览器可能会绕过强缓存直接进行协商缓存验证。
2. 用户强制刷新（Ctrl+F5或Shift+Reload）通常会忽略所有缓存，直接从服务器获取最新资源。

**总结**

HTTP缓存机制通过一系列头字段和策略，在客户端和服务器之间建立了高效的资源管理和重用机制。它不仅加速了网页加载，还减轻了服务器负担，优化了网络资源的使用效率。开发者通过精细控制这些缓存策略，可以在性能和资源新鲜度之间取得平衡。

### HTTPS

HTTPS（Hypertext Transfer Protocol Secure）是一种基于HTTP的通信协议，它通过在HTTP协议基础上加入SSL/TLS（Secure Sockets Layer/Transport Layer Security）协议层，为数据传输提供了安全性和完整性保障。HTTPS的设计目标是保护用户数据的隐私和安全，防止数据在传输过程中被窃听、篡改或伪造。以下是HTTPS的几个核心方面：

1. 加密传输
  - 对称加密：在实际传输数据前，客户端和服务器通过SSL/TLS握手过程协商出一个共享的会话密钥，然后使用这个密钥对传输的数据进行加密和解密。这样，即使数据被截获，没有密钥也无法解读其内容。
  - 非对称加密：在SSL/TLS握手阶段，服务器会向客户端发送自己的公钥，客户端使用公钥加密一个随机生成的对称密钥并发送给服务器，只有拥有私钥的服务器才能解密得到这个对称密钥，保证了密钥交换的安全性。
2. 身份验证
  - HTTPS协议要求服务器必须具备有效的SSL证书，该证书由受信任的证书颁发机构（CA）签发。证书包含了服务器的公钥以及服务器的身份信息。客户端在建立连接前会验证服务器证书的真实性，确保与预期的服务器通信，防止中间人攻击。
3. 数据完整性
  - 除了加密，HTTPS还通过消息认证码（MAC）或数字签名确保数据在传输过程中不被篡改。任何对传输数据的改动都会导致校验失败，从而被检测出来。
4. 安全标志
  - 浏览器地址栏中显示的锁形图标和“https://”前缀，向用户表明当前连接是安全的，增强了用户的信任感。
5. 性能影响
  - 尽管HTTPS增加了额外的加密和验证步骤，可能对性能有一定影响，但现代的硬件加速、会话复用（如TLS会话票证和HTTP/2的多路复用）等技术显著减少了这种开销，甚至在某些场景下，HTTPS的性能与HTTP相当或更好。
6. 搜索引擎优化（SEO）
  - 搜索引擎如Google倾向于优先索引HTTPS站点，将其视为排名信号之一，鼓励网站采用HTTPS以提升搜索排名。
7. 广泛应用
  - HTTPS不再局限于银行、电商等高敏感性网站，现在已成为Web标准，许多主流网站和服务均采用HTTPS来保护用户数据和提升用户体验。

综上所述，HTTPS通过加密、身份验证和数据完整性保护，为Web通信提供了强大的安全保障，是现代互联网安全通信的基础。

# 待定

## 异步请求

异步请求，英文通常称为 "Asynchronous Request"，是Web开发中的一个重要概念，特别是在实现动态页面、提升用户体验方面。它允许浏览器在不重新加载整个网页的情况下，与服务器交换数据并更新部分网页内容。这对于创建流畅的用户界面非常关键，因为用户可以在后台数据加载的同时继续与网页交互。

**原理**

在传统的同步请求中，浏览器发送请求到服务器，然后等待服务器响应，期间浏览器不能做其他操作。而异步请求则不同，它使用JavaScript（通常配合Ajax技术）在后台与服务器通信，这意味着：

1. **非阻塞**：用户可以继续与页面上的其他元素互动，比如滚动、点击等，而不会因为请求处理而卡顿。
2. **局部刷新**：只更新页面上需要改变的部分，而不是整个页面重载，提高了效率和用户体验。
3. **提高响应性**：通过在后台处理长时间运行的任务，如数据库查询，使应用感觉更快速和灵敏。

**实现方式**

异步请求的主要实现技术有：

- **Ajax（Asynchronous JavaScript and XML）**：虽然名字中有XML，但实际上现代应用更多使用JSON格式进行数据交换。Ajax是最早也是最常用的实现异步请求的技术，通过XMLHttpRequest对象与服务器通信。
- **Fetch API**：这是现代浏览器提供的一个更强大、灵活的请求数据的方法，相比Ajax，Fetch API提供了更简洁的语法和对Promise的支持，使得处理异步操作更加方便。
- **jQuery.ajax()**：jQuery库提供的一个简化版的Ajax请求方法，通过封装原生的XMLHttpRequest对象，提供了更易用的API接口。
- **axios, fetch-jsonp, superagent** 等第三方库：这些库为开发者提供了高级功能，如拦截请求和响应、自动转换请求和响应数据、以及更好的错误处理机制。

**应用场景**

异步请求广泛应用于各种Web应用场景中，包括但不限于：

- 动态加载内容：如无限滚动、分页加载数据。
- 表单提交：即时验证、无刷新提交表单。
- 实时通知：如聊天应用中的消息推送、系统通知。
- 数据检索与过滤：搜索建议、动态筛选列表。

总之，异步请求是构建现代Web应用程序不可或缺的一部分，它极大地改善了用户体验，使得Web应用更加动态、高效和响应迅速。

## 数据模型类

### 结果（Result）类

结果类的目的是封装控制器返回的响应数据，包括状态、消息和数据内容。它的作用在于：

1. **统一格式**：结果类定义了统一的数据格式，使得控制器返回的响应在结构上保持一致性，便于客户端进行解析和处理。
2. **清晰明确**：通过结果类，可以清晰地区分响应的状态、消息和数据，使得客户端能够更容易地理解和处理返回的信息。
3. **可扩展性**：结果类可以根据实际需求进行扩展，例如添加额外的字段或元数据，以满足不同场景下的需求变化。
4. **方便处理异常**：结果类也可以用于封装异常信息，并统一返回给客户端，使得异常处理更加统一和规范化。

结果类通常包含三个主要部分：状态（state）、消息（message）和数据（data）。这三部分用于描述请求的处理结果，以便客户端能够清晰地了解返回的信息。

一般来说，结果类的定义如下所示：

```
java复制代码public class Result<T> {
    private int state;       // 状态码
    private String message;  // 消息
    private T data;          // 数据

    // 构造函数、getter和setter方法
}
```

在这个示例中，`Result` 类使用了泛型 `T`，以便可以灵活地定义不同类型的数据。状态码（state）通常用整数表示，用于表示请求处理的结果，比如成功、失败、错误等不同情况对应不同的状态码。消息（message）用于描述请求处理的详细信息，通常是一段文本，可以包含错误信息、提示信息等。数据（data）部分则用于存储请求处理成功后返回的数据，可以是任意类型的对象，根据实际情况定义。

根据具体的业务需求，结果类的定义可能会有所不同，可以根据实际情况添加或修改字段，以满足项目的需求。例如，可以添加额外的元数据字段、错误码字段等，以实现更丰富的功能和更灵活的数据传递。

### 数据传输（DTO）类

DTO（Data Transfer Object）结尾的类是用于数据传输的对象。在软件开发中，DTO 是一种常见的设计模式，用于在不同层之间传输数据，通常用于服务层（Service Layer）和表示层（Presentation Layer）之间的数据传输。

DTO 结尾的类通常具有以下特点和作用：

1. **数据传输**：DTO 类用于在不同的软件组件或系统模块之间传输数据。它们承载着业务实体的数据，并提供给其他模块使用，通常用于服务端和客户端之间、后端和前端之间的数据传递。
2. **数据封装**：DTO 类封装了多个属性，代表了一个完整的数据对象。这些属性可以是业务实体的部分属性，也可以是从多个实体组合而成的新对象。
3. **跨层传输**：由于DTO通常位于不同层之间，它们的设计应该尽可能与特定的业务逻辑无关，而是专注于数据的传输和表示。这样可以保持系统的松耦合性，使得不同层的变化不会影响到彼此。
4. **性能优化**：在某些情况下，DTO 可以用于优化性能，例如减少数据库查询的数据量，只传递客户端需要的部分数据，从而提高系统的响应速度和效率。

总之，DTO 结尾的类用于在不同层之间传输数据，促进系统的解耦和灵活性，同时也有助于提高系统的性能和可维护性。

DTO（Data Transfer Object）通常用在表示层（Presentation Layer）和服务层（Service Layer）之间的代码中。在这两个层级中，DTO 扮演着数据传输的角色，帮助表示层与服务层之间进行数据交换和传递。

1. **在表示层（Presentation Layer）**：DTO 用于表示层的控制器（Controller）或者前端（Frontend）代码中。在这里，DTO 承载着从服务层获取的数据，或者将用户输入的数据传递给服务层。例如，在 Web 应用中，前端页面通过 DTO 对象向后端发送请求，或者接收后端返回的数据。
2. **在服务层（Service Layer）**：DTO 也用于服务层中的服务（Service）或者业务逻辑代码中。在这里，DTO 扮演着传输数据的角色，服务层通过 DTO 对象接收表示层传来的数据，并处理业务逻辑，然后将结果封装成 DTO 对象返回给表示层。服务层中的方法通常接收和返回 DTO 对象，而不是直接操作数据库实体或者其他持久化对象。

因此，DTO 在表示层和服务层之间扮演着数据传输的桥梁，帮助这两个层级之间进行解耦，同时确保数据的传递和处理符合业务逻辑和需求。

```java
// 一个简单的DTO示例，用于在表示层和服务层之间传输用户数据

// UserDTO.java

public class UserDTO {
    private Long id;
    private String username;
    private String email;
    
    // 构造函数、getter和setter方法
    
    public UserDTO(Long id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }
    
    // 省略getter和setter方法...
}

// UserService.java

public interface UserService {
    UserDTO getUserById(Long id);
    void saveUser(UserDTO userDTO);
}

// UserServiceImpl.java

@Service
public class UserServiceImpl implements UserService {
    
    // 注入持久层的UserRepository等
    
    @Override
    public UserDTO getUserById(Long id) {
        // 从持久层获取User实体，然后转换成UserDTO对象返回给表示层
        User user = userRepository.findById(id).orElse(null);
        if (user != null) {
            return new UserDTO(user.getId(), user.getUsername(), user.getEmail());
        }
        return null;
    }
    
    @Override
    public void saveUser(UserDTO userDTO) {
        // 将接收到的UserDTO对象转换成User实体，然后保存到持久层
        User user = new User();
        user.setUsername(userDTO.getUsername());
        user.setEmail(userDTO.getEmail());
        // 设置其他属性...
        userRepository.save(user);
    }
}
```

在这个示例中，`UserDTO` 类被用于表示层和服务层之间传输用户数据。在 `UserService` 接口中定义了获取用户和保存用户的方法，这些方法接收和返回 `UserDTO` 对象。在 `UserServiceImpl` 类中，实现了这些方法，通过DTO对象与持久化实体之间进行数据转换和传输。

### 实体（Entity）类

实体类的作用是代表系统或应用程序中的真实世界对象或概念。以下是它们的作用：

1. **抽象化**：实体类将真实世界的实体抽象成软件系统中可管理和理解的组件。它们封装了与特定实体相关的数据（属性）和行为（方法）。
2. **数据表示**：它们提供了一种结构化的方式来表示和组织数据。每个实体类通常对应于关系数据库中的一张表或NoSQL数据库中的一个文档，从而促进了数据存储、检索和操作。
3. **封装**：实体类封装了相关数据和操作在一个单元内。这种封装通过隐藏实体的内部细节，促进了模块化、可重用性和可维护性。
4. **关系管理**：实体类通常模拟不同实体之间的关系。例如，在电子商务系统中，`Customer` 实体可能与 `Order` 实体具有一对多的关系，其中每个客户可以有多个订单。
5. **业务逻辑实现**：它们封装了与特定实体相关的业务逻辑。这包括验证规则、计算和其他在系统中管理实体行为的操作

### 接口管理

我们对一个或多个系统中的很多用例进行维护，即对用例进行分类管理。如下：

1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）
2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）
3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。

<img src="https://pic2.zhimg.com/v2-f5bd635b77c4e1891f9eb70459228505_r.jpg" alt="img" style="zoom:50%;" />

### 请求接口

![屏幕截图 2024-04-18 095121](开发理论.assets/屏幕截图 2024-04-18 095121.png)

**请求：**

- 请求方法：GET
- 请求URL：http://localhost/index.php?m=Home&c=User&a=do_login&t=0.21942974229794432
- 请求头：Content-Type：XXX
- 请求体：XXX=XXX&YYY=YYY

Postman支持多种请求体类型，具体取决于您的API的需求和配置。以下是常见的请求体类型：

- **Form-Data**: 用于向服务器发送表单数据，通常用于提交表单或文件上传。您可以通过Postman的“Body”选项选择“form-data”类型，并添加键值对参数。
- **x-www-form-urlencoded**: 类似于表单数据，但数据以键值对形式编码在请求的正文中。在Postman中，选择“x-www-form-urlencoded”类型，并添加键值对参数。
- **Raw**: 允许您直接输入原始数据，如JSON、XML或文本。在Postman中选择“Body”，然后选择“raw”类型，并在下拉菜单中选择相应的格式（如JSON）。
- **Binary**: 用于发送二进制数据，例如图像或音频文件。在Postman中，选择“Body”，然后选择“binary”类型，并上传您的文件。
- **GraphQL**: 专门用于发送GraphQL查询。在Postman中，选择“Body”，然后选择“GraphQL”类型，并输入您的GraphQL查询。
- **其他类型**: 根据您的需求，您可能还会遇到其他类型的请求体，如SOAP等。在Postman中，选择适合您需求的类型，并按需设置参数。

您可以根据您的API端点的要求选择适当的请求体类型，并在Postman中相应地设置请求体。

### 响应接口

![img](https://pic2.zhimg.com/80/v2-f857caac945ae316db943d49fb760659_1440w.webp)

**响应：**

- 状态行：Status：200 OK
- 响应头：Headers + Cookies，需要注意的是Cookies是包含在响应头中的，但是为了明显，工具会分开显示
- 响应体：Body

响应体类型通常是根据服务器返回的数据类型而确定的。Postman会根据接收到的响应自动识别响应体类型。以下是一些常见的响应体类型：

- **JSON**: 最常见的响应体类型之一，用于传输结构化数据，例如API响应。
- **XML**: 另一种常见的响应体类型，用于传输标记语言数据，如配置文件或数据交换。
- **HTML**: 用于传输网页内容的响应体类型，通常用于Web应用程序。
- **文本/纯文本**: 用于传输纯文本数据的响应体类型，例如文档或日志文件。
- **二进制数据**: 用于传输图像、音频、视频等二进制数据的响应体类型。
- **其他类型**: 根据服务器返回的数据内容，可能还会有其他自定义的响应体类型。

在Postman中，您可以通过查看响应的“Body”部分来确定响应体类型。Postman通常会根据响应的内容类型自动解析响应体类型，并以适当的方式显示数据。

如果您需要处理特定类型的响应体，例如解析JSON或提取特定的信息，Postman提供了相应的功能和工具来帮助您处理不同类型的响应。
