

# MySQL SQL语句执行过程

以MySQL8.0为例，SQL语句执行过程分以下阶段：

1. 连接管理
   - 客户端与MySQL服务器建立TCP连接
   - 进行身份验证
   - 获取权限信息
2. 查询缓存
   - MySQL8.0已经移除，因为一旦涉及表的更新，就会导致缓存失效，从而缓存命中率较低，只适合静态表
3. 解析与预处理
   - 词法分析：将SQL语句分解成一个个单词
   - 语法分析：检查SQL的语法是否正确
   - 语义分析：检查表名、列名等是否存在
   - 构建解析树
4. 查询优化
   - 重写查询
   - 选择合适的索引
   - 决定表的连接顺序
   - 预估不同执行计划的成本
5. 执行计划生成
   - 根据优化结果生成可执行的操作序列
   - 可以使用EXPALIN命令查看执行计划
6. 查询执行
   - 调用存储引擎来查询数据
   - 进行排序、分组等操作
   - 执行各种函数运算
7. 结果返回
   - 将查询结果返回给客户端
   - 如果结果集较大，通常会分批次返回

**示例**

```sql
SELECT username, gender FROM user WHERE username = 'Lisa';
```

1. 词法分析

   - 将SQL语句分解成单个词元（token）：
     SELECT, username, gender, FROM, user, WHERE, username, =, 'Lisa'

2. 语法分析

   - 检查SQL语句的语法结构是否正确
   - 构建抽象语法树（AST）

3. 语义分析

   - 验证表名 'user' 是否存在
   - 检查列名 'username' 和 'gender' 是否存在于 'user' 表中
   - 确认 'username' 列可以用于等值比较

4. 查询重写（如果需要）

   - 这个简单查询可能不需要重写
   - 但如果有视图或者某些复杂的条件，可能会在这一步进行重写

5. 权限检查

   - 确认当前用户有权限查询 'user' 表的 'username' 和 'gender' 列

6. 优化阶段

   - 确定访问方法：
     - 检查 'username' 列上是否有索引
     - 如果有索引，决定是否使用索引
   - 估算不同执行计划的成本：
     - 全表扫描的成本
     - 使用索引的成本（如果有适用的索引）
   - 选择最优的执行计划

7. 生成执行计划

   - 基于优化结果，生成详细的执行步骤

   - 可能的执行计划：

     a) 如果 'username' 上有索引：

     - 使用索引查找等于 'Lisa' 的记录
     - 获取匹配记录的 'username' 和 'gender' 列
       b) 如果没有适用的索引：
     - 全表扫描
     - 对每一行检查 'username' 是否等于 'Lisa'
     - 对匹配的行，返回 'username' 和 'gender' 列

8. 准备执行

   - 可能会分配临时内存来存储结果
   - 准备调用存储引擎的相关接口

这个过程可以通过 EXPLAIN 命令来查看：

```sql
EXPLAIN SELECT username, gender FROM user WHERE username = 'Lisa';
```

这会显示MySQL选择的执行计划，包括：

- 使用的索引
- 扫描的行数估计
- 访问类型（如 const, ref, ALL 等）

理解这个过程有助于优化查询性能。例如，如果发现MySQL没有使用预期的索引，可能需要检查索引是否正确创建，或者考虑优化表结构或查询语句。

# MySQL日志

MySQL有几种重要的日志，它们用于不同的目的，包括故障排除、性能优化、安全审计等。以下是MySQL中主要的日志类型：

1. 错误日志（Error Log）
   - 记录MySQL服务器启动、运行和关闭过程中的问题
2. 通用查询日志（General Query Log）
   - 记录所有客户端连接和执行的语句
   - 默认关闭，因为会影响性能
3. 慢查询日志（Slow Query Log）
   - 记录执行时间超过指定阈值的查询
   - 用于识别需要优化的查询
4. 二进制日志（Binary Log）
   - 记录所有修改数据的语句
   - 用于复制和时间点恢复
5. 中继日志（Relay Log）
   - 在主从复制中使用
   - 从服务器用来存储从主服务器接收的二进制日志事件
6. DDL日志（DDL Log，MySQL 8.0新增）
   - 记录数据定义语言（DDL）操作
7. 事务日志（Transaction Log / InnoDB Redo Log）
   - InnoDB存储引擎使用
   - 记录事务相关的修改，用于崩溃恢复

## binlog和redo log

1. binlog（二进制日志）

   binlog是MySQL的逻辑日志,记录了对数据库执行更改的所有操作。主要用于:

   - 主从复制:slave通过读取master的binlog来同步数据。
   - 数据恢复:通过binlog可以恢复到某个时间点的数据状态。

2. redo log（重做日志）

   redo log是InnoDB存储引擎特有的物理日志,用来保证事务的持久性。主要作用:

   - 崩溃恢复:系统崩溃时,可以通过redo log恢复已提交的事务数据。

   特点：

   - 记录的是对于每个页的修改。
   - 由InnoDB存储引擎层生成。
   - 是循环写入的,空间固定。
   - 事务执行过程中就开始写入。

3. 二阶段提交

   为了保证binlog和redo log的一致性,MySQL使用二阶段提交机制：

   第一阶段（prepare阶段）：

   1. 写入redo log，处于prepare状态
   2. 写入binlog

   第二阶段（commit阶段）：

   3. 修改redo log为commit状态

   整个过程如下：

   ```
   1. 执行事务中的SQL语句
   2. 写入redo log(prepare状态)
   3. 写binlog
   4. 提交事务,修改redo log为commit状态
   ```

   这样设计的目的是为了在崩溃恢复时,能够判断事务是否已经提交:

   - 如果redo log是commit状态,说明事务已经提交,直接恢复。
   - 如果redo log是prepare状态,还需要查看binlog是否完整:
     - 如果binlog完整,则提交事务。
     - 如果binlog不完整,则回滚事务。

   这种机制保证了binlog和redo log的一致性,从而保证了主从复制的数据一致性。

4. 写入过程的性能优化

   - binlog的写入是追加写入,顺序IO,性能较好。
   - redo log采用循环写入方式,也是顺序IO。
   - 都采用了组提交(group commit)机制,可以将多个事务的日志一起写入,提高性能。

总结:binlog和redo log通过二阶段提交机制配合工作,共同保证了MySQL的数据一致性和可靠性。理解它们的工作原理对于优化MySQL性能和排查问题都很有帮助。

## 慢查询日志和EXPLAIN工具性能优化

1. 开启慢查询日志：
   - 设置long_query_time参数，捕获执行时间超过这个阈值的查询。
   - 分析日志，找出最耗时的查询。
2. 使用EXPLAIN分析查询计划：
   - 在查询前加上EXPLAIN关键字，查看执行计划。
   - 关注以下几点： 
     - a) type列：查看访问类型，从好到坏依次是：system > const > eq_ref > ref > range > index > ALL 
     - b) key列：查看使用的索引
     - c) rows列：估计要检查的行数 
     - d) Extra列：包含额外信息，如"Using filesort"、"Using temporary"等需要特别注意
3. 优化步骤：
   - 对于没有使用索引的查询，考虑添加合适的索引。
   - 如果使用了文件排序（Using filesort），考虑添加排序字段的索引。
   - 如果使用了临时表（Using temporary），考虑重写查询以避免临时表。
   - 对于扫描行数过多的查询，考虑添加更多的查询条件或优化现有索引。
4. 使用profiling：
   - 设置profiling = 1，然后执行查询。
   - 使用SHOW PROFILES和SHOW PROFILE FOR QUERY n查看详细的执行时间分布。
5. 考虑查询重写：
   - 有时候，重写查询逻辑可能会带来显著的性能提升。
6. 优化数据库配置：
   - 调整buffer pool大小、innodb_flush_log_at_trx_commit等参数。
7. 考虑分区或分表：
   - 对于超大表，考虑使用分区或分表策略。
8. 使用缓存：
   - 对于频繁访问但不常变化的数据，考虑使用缓存层（如Redis）。

# 有哪些SQL语句编写的最佳实践

1. 使用合适的索引：
   - 在WHERE子句、JOIN条件和ORDER BY子句中经常使用的列上创建索引。
   - 避免在索引列上使用函数，这会导致索引失效。
2. 避免使用SELECT *：
   - 只选择需要的列，减少数据传输和处理量。
3. 使用LIMIT限制结果集大小：
   - 特别是在大型表上进行查询时，可以显著提高性能。
4. 优化JOIN操作：
   - 使用内连接代替外连接（如果可能）。
   - 确保连接条件使用了索引。
5. 避免在WHERE子句中使用OR：
   - 使用UNION ALL替代OR可能会更高效。
6. 使用EXISTS代替IN：
   - 当子查询返回大量记录时，EXISTS通常比IN更快。
7. 避免使用通配符开头的LIKE语句：
   - 例如，避免使用'%abc'，这会导致全表扫描。
8. 合理使用子查询：
   - 有时使用JOIN比子查询更高效。
9. 使用合适的数据类型：
   - 选择正确的数据类型可以优化存储和查询效率。
10. 定期更新统计信息：
    - 这有助于查询优化器做出更好的决策。

# MySQL 设计索引

1. 索引类型：
   - B-Tree索引：最常用的索引类型，适用于全键值、键值范围和键前缀查询
   - Hash索引：只适用于等值查询，查询速度快
   - 全文索引：用于全文搜索
   - 空间索引：用于地理空间数据类型
2. 索引创建：
   - CREATE INDEX语句
   - ALTER TABLE语句添加索引
   - 创建表时在列定义中指定索引

**设计过程**

1. 分析查询模式：查看日志、监控工具，找出最常用和性能最关键的查询。
2. 选择合适的列建立索引：
   - 经常出现在WHERE子句中的列
   - 经常用于连接的列（如外键）
   - 经常需要排序或分组的列
3. 使用复合索引： 对于经常一起使用的多个列，我会考虑创建复合索引。
4. 避免过度索引： 虽然索引可以提高查询速度，但也会增加写入和维护成本。

# MySQL 主从复制 读写分离

## 为什么采取主从复制 读写分离？

主要是为了提升数据库的并发性能，比方有三台数据库服务器可用，数据库的访问请求可以分发到不同的服务器，提升系统整体的性能；如果某台服务器出故障，至少不至于丢失数据，保证可用性。

再者读操作频率往往远高于写操作频率，所以将数据库的读写操作分开处理，比如主服务器进行写操作，其他从服务器进行读操作，可显著提高读操作的性能。

## 主从复制原理

1. 主节点进行写操作（插入、修改、删除），并将操作记录写入binlog
2. 从节点连接到主节点，请求获取binlog，主节点将新的日志发送给从节点
3. 从节点拿到新的日志后，将其写入relay log
4. 从节点的SQL线程读取到relay log，并更新数据库

## 问题

复制的过程是异步的，主节点不会等待从节点的确认，所以会导致主从库之间会出现短暂的数据不一致。

解决办法：

- 延迟控制，如果延迟超过限定值，将请求路由推给主服务器
- 对数据一致性要求高的操作，直接访问主服务器

# MySQL分库分表

分库分表是一种用于处理大规模数据和高并发访问的数据库优化策略。

**概念**

- 分库：将一个数据库拆分成多个独立的数据库实例。
- 分表：将一张大表拆分成多张更小的子表。

**分库分表方式**

- 垂直分库：按业务模块拆分成不同的数据库。
- 水平分库：同一个业务模块的数据分散到不同的数据库实例中。
- 垂直分表：将一张表按列拆分成多张表。
- 水平分表：将一张表的行数据拆分到多张表或多个库中。

**分片策略**

- 范围分片：如按ID范围或时间范围分片。
- 哈希分片：使用哈希函数将数据均匀分布。
- 列表分片：根据枚举值进行分片。
- 复合分片：结合多种分片策略。

**优点**

- 提高查询性能：减少单表数据量，提升查询速度。
- 增强可扩展性：更容易横向扩展。
- 提高并发能力：分散数据库压力。
- 改善系统稳定性：单个分片故障不影响整体系统。