# 缓存更新策略

缓存更新是为了节约内存使用，大体分为三种：

- 内存淘汰：当Redis内存占用达到设置的max-memory时，会自动触发淘汰机制
- 超时剔除：为缓存数据设置过期时间，超时的缓存数据会被淘汰
- 主动更新：编写业务逻辑，解决缓存与数据库不一致的问题

**最佳实践**

- 低一致性需求：使用Redis自带的内存淘汰机制
- 高一致性需求：主动更新，并以超时剔除作为兜底方案
  - 读操作：
    - 缓存命中则直接返回
    - 缓存未命中则查询数据库，并写入缓存，设定超时时间
  - 写操作：
    - 先写数据库，然后再删除缓存
    - 确保数据库与缓存操作的原子性，尤其是并发情况下顺序反过来可能导致数据不一致

# 怎么选择要缓存的数据？

- 使用工具或日志分析识别高频访问的数据
- 优先缓存大小适中的数据，避免缓存过大的对象
- 优先缓存相对稳定的数据，避免频繁更新导致的缓存失效
- 优先缓存对业务影响大的数据，如首页数据、热门商品等
- 优先缓存计算复杂或耗时的数据
- 实时监控缓存内存使用情况，动态调整缓存策略
- 定期分析缓存命中率，调整缓存策略
- 对不同重要性的数据采用不同的缓存策略
- 基于系统负载和访问模式动态调整缓存策略

# Redis缓存可能的问题

## 什么是缓存穿透？

缓存穿透是指查询一个根本不存在的数据，导致每次请求都穿透缓存到达数据库。

问题：

- 如果有大量这样的请求，会对数据库造成巨大压力。
- 可能被恶意利用，导致系统瘫痪。

解决方案：

- **布隆过滤器**：

  布隆过滤器采用哈希思想解决问题，通过hash函数判断这个key有没有对应的数据，如果判断存在，就去访问缓存；如果判断不存在，就直接返回。

- **缓存空对象**

  对于不存在的数据，也将其缓存起来，如果再来这样的请求，就直接访问缓存了，不至于频繁访问数据库。


## 什么是缓存击穿？

缓存击穿是指一个被高并发访问并且缓存重建业务较复杂的热点key突然失效，导致大量并发请求直接击穿缓存到达数据库。

过程：有多个并发请求查询同一个缓存，那么都没在缓存中找到，第一个访问的想重建缓存也没那么快，就导致多个请求都查询到数据库。

问题：

- 可能导致数据库瞬间压力激增。
- 影响系统的稳定性。

解决方案：

- **互斥锁**

  使用互斥，保证对于同一个key，只有一个线程去查询数据库，其他线程休眠一会，等第一个线程重建完缓存，再去缓存查询。

  这种实现方式比较简单，一致性也好，但是由于线程需要等待，所以性能差一些，也有死锁风险。
  
- **热点数据逻辑过期**

  对于某些热点数据，我们在缓存中存储数据时，同时存储一个逻辑过期时间。

  过程：如果一个线程在查询缓存数据时，如果发现到了逻辑过期时间，就尝试获取一个互斥锁，然后开启一个新的线程去更新缓存，原来的线程以及在缓存更新之前访问该缓存的线程，拿到的都是旧数据。
  
  这种实现方式优点是性能好，缺点是有一个时间内数据不一致。

## 什么是缓存雪崩？

缓存雪崩是指大量缓存数据在同一时间集中过期，导致大量请求直接落到数据库上。

问题：

- 可能导致数据库瞬间压力过大而宕机。
- 引发系统级的故障。

解决方案：

- **过期时间添加随机值**：

  为缓存的过期时间添加一个随机值，避免同时失效。

- **多级缓存**：

  使用多级缓存，不同级别的缓存设置不同的过期时间。

- **熔断降级**：

  当检测到缓存大规模失效时，启动熔断机制，返回默认值或旧数据。


# Redis持久化？

Redis是一款内存数据库，持久化就是说将内存里面的数据备份到磁盘。

**RDB（Redis Database）持久化**：

RDB是Redis默认的持久化方式，通过在指定的时间间隔内将内存里面的数据集快照写入磁盘，恢复时将快照文件直接读到内存。

过程：Redis会单独创建（Fork）一个子进程进行持久化，被fork出来的子进程会继承主进程的内存映像的一个副本，然后子进程会创建一个临时文件，待持久化过程完成后，就通知主进程，主进程将新的RDB文件替换旧的RDB文件，然后子进程生命周期结束。

优点：

- 性能好
- 适合大规模的数据恢复
- 占空间相对小

缺点：

- 有可能会丢失最后一次快照后的所有修改

**AOF（Append Only File）持久化**：

AOF通过以日志的形式记录每一个写操作，并且持久化到磁盘。

过程：AOF文件对写操作进行日志追加，当AOF文件较大时，会进行后台重写，恢复时读取AOP文件中的所有命令并依次执行，以此来重建数据集。

优点：

- 数据一致性高

缺点：

- 占用空间相对大
- 性能相对差

**持久化策略**：

- 大部分情况建议采用 RDB
- 如果对数据的一致性要求比较高，建议使用 AOF
- 如果既想要性能又想要安全性，可以使用混合持久化

# Redis发布/订阅？

Redis的发布订阅(pub/sub)是一种消息通信模式,它可以让消息发送者(发布者)发送消息,而不需要知道具体的接收者(订阅者)。订阅者可以订阅一个或多个频道,并接收发布到这些频道的消息。

以下是Redis发布订阅的主要特点和使用方法:

1. 主要命令:

   - SUBSCRIBE: 订阅一个或多个频道
   - PUBLISH: 向一个频道发布消息
   - UNSUBSCRIBE: 取消订阅一个或多个频道
   - PSUBSCRIBE: 订阅一个或多个符合给定模式的频道
   - PUNSUBSCRIBE: 取消订阅一个或多个符合给定模式的频道

2. 基本使用:

   订阅者:

   ```
   SUBSCRIBE channel1 channel2
   ```

   发布者:

   ```
   PUBLISH channel1 "Hello World"
   ```

3. 特点:

   - 解耦: 发布者和订阅者之间没有直接联系
   - 多对多: 一个频道可以有多个发布者和订阅者
   - 实时性: 消息发布后立即传递给订阅者

4. 使用场景:

   - 实时消息系统

   - 实时聊天

   - 任务分发

   - 实时通知

5. 注意事项:

   - 消息不持久化: 如果订阅者断开连接,它将无法接收断开期间发布的消息

   - 消息可能丢失: 如果Redis服务器宕机,未发送的消息将丢失

   - 订阅者数量影响性能: 订阅者数量过多可能影响Redis性能