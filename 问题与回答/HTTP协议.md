# **HTTP协议使用场景？**

在Web客户端（通常是Web浏览器）与Web服务端之间，采用HTTP协议作为通信的规则。

请求资源的一端叫做客户端，提供资源响应的一端叫做服务器端。

# **TCP/IP协议族为什么采用分层管理？**

首先为了解耦，如果只存在一个协议统筹全局，那么当某个组件需要修改时，可能要涉及的内容很多。如果采用分层设计，由于不同层级之间通过接口联络，每个层级内部的改动，并不影响该层级对上层提供服务。

其次，这样也能让业务逻辑更加清晰，每个层级只完成一个相应的任务，而不考虑其他的问题。

# **TCP/IP各个层级分别干什么？**

- 应用层：与用户操作的程序（浏览器、电子邮箱客户端）交互，并通过下层协议进行通信。具体说就是将应用程序产生出的数据封装成适合网络传输的格式，以及如何解析接收到的数据。
- 传输层：提供端到端的通信服务，主要关注数据传输的机制（质量保证和服务特性），确保数据有效且可靠
- 网络层：负责确定数据包要发送到的地址（通过IP地址寻址）和决定数据包在网络中的传输路径（即路由）
- 数据链路层：负责在数据链路进行数据帧的传输，简而言之，处理连接网络的硬件部分

# **讲一下IP协议？**

IP协议是网络层的协议，当传输层的数据段到达网络层，会在每个数据段上附带相应的IP信息（源IP地址、目的IP地址、生存时间等），形成数据包，IP协议使用IP地址作为唯一标识，再通过路由表和路由协议，逐步的传输数据包，直至到达目的地。

IP协议的传输过程不需要预先建立连接，每个IP数据包独立寻址和路由，不保证到达顺序，也不负责数据包的丢失和重复问题。

*路由过程：*当一个数据包到达路由器，首先检查数据包的目的IP地址，看能不能给直接连接目的网络，可以就将数据包转发到相应的输出接口；如果目的网络不是直连的，路由器就会在路由表中查找，通过一定的路由算法找到下一跳地址或输出接口转发数据包，并更新生存时间。循环以上过程，直至到达目的地。

# **IP地址和MAC地址的区别？**

- IP地址是逻辑地址，是互联网协议中的全局唯一的标识符，表示网络上的每一台设备。它定义了设备在网络空间中的位置，但是不考虑数据链路层的实现细节，IP地址可以重新分配，以适用网络的变化。
- MAC地址是物理地址，是网卡的唯一标识。全球唯一，不可更改，代表设备在物理网络中的身份，用于局域网的直接通信。在ARP协议（地址解析协议）中用于将IP地址映射到实际的物理地址，以实现同一局域网设备间的之间通信。

# **讲一下TCP协议？**

TCP是一种面向连接、可靠的、基于字节流的传输层协议。

- 面向连接是指建立连接时采用三次握手机制，和关闭连接时采用四次挥手机制。
- 可靠性是指TCP通过序列化与确认应答、流量控制、拥塞控制、校验和等机制确保数据的可靠传输
- 字节流服务是指TCP会将应用层的数据根据网络状况拆分为多个数据段进行管理传输

*TCP三次握手过程：*

1. 第一次握手：
   - 客户端发送一个SYN标志的TCP报文到服务端，并随机选择一个初始化序列号ISN。
   - 这个报文告诉服务端，客户端希望建立连接。
2. 第二次握手：
   - 服务端受到客户端的SYN报文后，如果同意建立连接，则会发送一个SYN标志的报文作为应答，该报文中也会包含一个服务端选择的初始序列化ISN
   - 同时，服务端还会把客户端的ISN加1作为确认应答的序列化，即ACK=Client ISN+1，表示已经收到了客户端的SYN报文。
   - 这个报文称为SYN+ACK报文
3. 第三次握手：
   - 客户端收到服务器的SYN+ACK报文后，会发送一个ACK标志的报文给服务器
   - 这个ACK报文的确认序列号ACK=Server ISN + 1，表示已经收到了服务器的SYN报文。
   - 至此，客户端和服务器都确认了对方的接收能力，连接建立完成。

*TCP四次挥手过程：*

1. 第一次挥手：
   - 当客户端完成数据传输后，他会发送一个FIN标志的报文给服务器，告诉服务器没有更多数据要发送了
   - 客户端进入FIN_WAIT_1状态
2. 第二次挥手：
   - 服务器接收到客户端的FIN报文后，会发送一个ACK确认报文给客户端
   - 这个ACK报文的确认序列号ACK=Client FIN + 1，告诉客户端我已收到你的断开请求
   - 服务器可能还有数据要发送给客户端，所以服务器此时并未关闭连接，而是进入了CLOSE_WAIT状态
   - 客户端收到这个ACK后，进入FIN_WAIT_2状态
3. 第三次挥手：
   - 当服务器确定没有数据要发送给客户端时，会发送一个FIN标志的报文给客户端，告诉客户端我也准备好关闭连接了
   - 服务器进入LAST_ACK状态
4. 第四次挥手：
   - 客户端收到服务器的FIN报文后，发送一个ACK确认报文给服务器
   - ACK报文的确认序列号ACK=Server FIN + 1，表明客户端已收到服务器的断开请求
   - 客户端进入TIME_WAIT状态，等待一段时间（通常为2MSL，最大报文生存时间的两倍）后关闭连接，以防有延迟的数据包到达
   - 服务器收到这个最终的ACK后，关闭连接

# **讲一下DNS协议？**

DNS（Domain Name System，域名系统）是一种分布式服务，它将人类可读的域名（www.example.com）转换为计算机可识别的IP地址（如192.0.0.1）。

*域名解析过程：*当用户在浏览器输入一个网址，客户端首先检查本地缓存中是否有该域名对应的IP地址；如果本地没有缓存，客户端将会向DNS解析器发送请求，一旦得到IP地址，相关信息将按照原路径返回到客户端，并配置缓存，以便未来更快响应。

# **一次TCP/IP网络传输的过程？**

首先用户在浏览器写入域名，DNS服务解析域名，返回IP地址，HTTP协议生成对应的HTTP请求报文，应用层的数据通过传输层的封装（添加TCP或UDP头部），再经网络层的IP封装（添加IP头部进行寻址和路由），最后在链路层被封装为适合物理媒介传输的格式。接收端则是逆过程，逐层进行解封装，直到数据到达对应的应用程序。

# **URI和URL？**

URI（Uniform Resource Identifier，统一资源标识符）和URL（Uniform Resource Locator，统一资源定位符）是描述互联网资源的两组概念。

URI主要是使用统一的方式来唯一地识别任何类型的资源，更关注于资源的身份识别。

URL是URI的子集，更关注于描述如何获取这个资源。

一个典型的URL包含一下部分：

- 协议方案（Scheme）：如http、https、ftp等，表示访问资源使用的协议
- 域名或IP地址（Host or IP）：这部分通常需要DNS解析来将其转换为IP地址，以便网络设备能够找到资源所在服务器。
- 端口号（Port，可选）：如果不写，默认使用协议的默认端口，如http默认是80，https默认是443。
- 路径（Path）：资源在服务器上的具体位置。
- 查询字符串（Query String，可选）：用于携带额外参数或过滤信息，以"?"开头。
- 片段标识符（Fragment Identifier，可选）：用"#"开头，用来标记文档内的某个位置或作为内部链接使用。

# **HTTP请求报文里包含哪些信息？**

- 请求行
  - 请求方法
  - 请求URI
  - 协议版本
- 请求首部
- 请求体

![image-20240614141600187](C:\Users\richa\Desktop\笔记\问题与回答.assets\image-20240614141600187.png)

# **HTTP响应报文里包含哪些信息？**

- 响应行
  - 协议版本
  - 状态码
  - 状态码的原因
- 响应首部
- 响应体

![image-20240614141917380](C:\Users\richa\Desktop\笔记\问题与回答.assets\image-20240614141917380.png)

# **为什么说HTTP是无状态协议？**

因为HTTP协议不会对请求和响应之间的通信状态进行保存，所以每一次请求-响应过程都是独立的，这是为了减轻服务器的负担，不需要为每个用户维持会话状态，减少资源消耗。

尽管HTTP是无状态的，为了记录一些用户状态信息，可以使用Cookie、Session等机制进行会话管理。

# **HTTP有哪些请求方法，都表示什么含义？**

- GET：用于请求访问被URI标识的资源。请求的数据会附在URL之后，以查询字符串的形式出现。
- POST：用于向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。
- PUT：用于替换服务器上现有的资源或在指定的URI下创建一个新的资源。
- HEAD：类似于GET请求，但服务器只返会响应头，不返回请求的主体部分，用于验证URI的有效性和资源更新日期。
- DELETE：请求服务器删除指定的资源。
- OPTIONS：查询指定请求URI资源支持的各种功能（如HTTP方法）。
- TRACE：追踪路径。
- CONNECT：要求用隧道协议连接代理。

# **HTTP 1.1相对HTTP 1.0增加了哪些特性？**

1. 持久连接
   - 持久连接指的是只要客户端和服务端都没有明确断开连接，则会维护TCP的连接状态，从而减轻服务端的负载
2. 管道化
   - 管道化指的是在接收到前一个请求的响应之前，连续发送多个请求。但服务器必须按照请求的接收顺序返回响应，这可能导致队头堵塞。

# **什么是Cookie？**

Cookie是一种由服务器通过HTTP响应头发送给客户端，并在之后客户端每一个请求都会将这个Cookie放在请求头回传给服务端的文本。它主要用于会话管理，个性化设置等。

# **HTTP请求报文首部包含哪些信息？**

HTTP请求报文首部包含了客户端向服务端传递的附加信息，用于描述请求上下文、客户端自身信息以及响应内容的偏好设置。

- 通用首部字段：请求报文和响应报文通用的部分
  - Cache-Control：缓存工作机制
  - Connection：控制不再转发给代理的首部字段/管理持久连接
  - Date：创建HTTP报文的日期和时间
  - Transfer-Encoding：传输报文主体时采用的编码方式
  - Upgrade：检测HTTP协议以及其他协议是否使用更高的版本进行通信
  - Via：追踪客户端与服务器端之间的请求和响应报文传输路径
- 请求首部字段：专用于请求报文，像服务器提供有关客户端功能或请求的额外信息。
  - Accept：客户端能够处理的媒体类型及媒体类型的相对优先级
  - Accept-Charset：客户端支持的字符集以及字符集的相对优先级
  - Accept-Encoding：客户端支持的内容编码及内容编码的相对优先级
  - Accept-Language：客户端支持的自然语言及自然语言的相对优先级
  - Authorization：客户端的认证信息
  - Host（必须包含）：请求的资源所处的互联网的主机名和端口
  - User-Agent: 客户端的类型、操作系统、浏览器等信息
  - Cookie：客户端保存的服务器cookie信息
- 实体首部字段：当请求报文中包含有实体内容时（如POST请求的数据），这些首部描述了实体内容的特征。
  - Allow: 资源支持的HTTP方法。
  - Content-Encoding: 实体内容的编码格式。
  - Content-Language: 实体内容的语言。
  - Content-Length: 实体内容的大小（以字节计）。
  - Content-Type: 实体内容的MIME类型。
  - ETag: 资源的唯一标识符，用于条件请求。
  - Last-Modified: 资源最后修改的时间。
- 扩展首部字段：除了标准的首部字段外，还可以有自定义的首部字段，这些通常是为特定的应用程序或服务定制的。

# **HTTP响应报文首部包含哪些信息？**

HTTP响应报文首部包含了服务器向客户端返回的附加信息，用于描述响应的状态及内容特性，以及与客户端和服务器通信相关的其他细节。

- 通用首部字段：请求报文和响应报文通用的部分
  - 同上
- 响应首部字段：专门用于响应报文，提供有关响应的详细信息
  - Age: 响应在代理缓存中存活的时间。
  - Location: 重定向到的URL。
  - Retry-After: 对于“503 Service Unavailable”响应，告知客户端何时重试请求。
  - Server: 服务器的软件信息。
  - Set-Cookie: 服务器发送给客户端的cookie信息。
  - WWW-Authenticate: 提示客户端进行认证的方式。
- 实体首部字段：描述响应报文中实体部分的元信息，适用于有实体主体的情况
  - 同上
- 扩展首部字段：非标准的首部字段，由特定应用程序或服务自定义使用

# **什么是HTTP协议的内容编码？**

HTTP协议的内容编码是一种在数据传输过程中对HTTP报文主体（请求体或响应体）进行压缩或转换的机制，客户端在接收数据后需要对其进行解码以恢复原始数据。

**请求体的内容编码：**

- 客户端：在发送请求前，如果客户端知道服务器支持某种内容编码（通常通过先前的交互或者配置信息得知），它可以先对请求体进行相应编码，然后在请求头的`Content-Encoding`字段标明所使用的编码方式。
- 服务器端：接收到请求后，服务器会检查`Content-Encoding`字段，如果支持该编码类型，就会对请求体进行解码，以便进一步处理原始数据。

**响应体的内容编码：**

- 客户端：当服务器准备发送响应时，它可以根据请求头中的`Accept-Encoding`字段来判断客户端支持的内容编码类型，然后选择合适的编码方式对响应体进行压缩，并在响应头的`Content-Encoding`字段中声明所使用的编码类型。
- 服务器端：接收到响应后，客户端检查`Content-Encoding`字段，如果支持该编码，则对响应体进行解码以还原原始数据。如果客户端不支持响应中声明的编码类型，可能无法正确处理响应内容。

# 什么是HTTP协议的分块传输编码？

这是一种数据传输机制，特别适用于那些在发送时无法预先确定内容长度的场合，例如动态生成的内容或流式数据。这种机制允许服务器将响应数据分割成一系列的数据块（称为“chunks”），逐一发送给客户端。

# 什么是HTTP协议的MIME机制？

这是一种用于标识内容类型的机制，确保网络上的数据能够被正确识别和处理。比方

- 发送请求时，客户端设置：Accept：text/html,application/json,...
- 接收响应时，服务器端设置：Content-Type：application/json，charset=utf-8

# 什么是HTTP状态码？

HTTP状态码用于当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知晓服务器是怎样处理的请求。

状态码分类：

|      | 类别                             | 原因                       |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Informational（信息性状态码）    | 接受的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求错误         |

常用状态码：

- 200：OK 客户端发送的请求被服务器端正确处理
- 204：No Content 客户端发送的请求成功处理，但是响应报文中不包含实体的主体信息
- 206：Partial Content 客户端进行范围请求，服务器成功处理
- 301：Moved Permanently 永久性重定向。请求的资源已被分配了新的URI，以后应使用资源现在所指的URI
- 302：Found 临时性重定向。请求的资源已被分配了新的URI，希望用户（本次）使用新的URI访问
- 303：See Other 由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源
- 304：Not Modified 客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况
- 307：Temporary Redirect 临时重定向。和302有相同含义。
- 400：Bad Request 请求报文存在语法错误。
- 401：Unauthorized 发送的请求需要有通过HTTP认证的认证信息。
- 403：Forbidden 对请求资源的访问被服务器拒绝。
- 404：Not Found 服务器上找不到请求的资源。
- 500：Internal Server Error 服务器端在执行请求时发送错误。
- 503：Service Unavailable 服务器处于超负载或者停机维护中，无法处理请求。

# Web服务器实现多个域名？

单台Web服务器实现多个域名是依赖于虚拟主机技术。

在基于域名的虚拟主机配置中，一个服务器上的多个网站可以共享相同的IP地址，每个网站通过其域名唯一标识。当Web服务器（如Apache或Nginx）接收到HTTP请求时，它会检查请求头中的Host字段来确定请求的是哪个域名，然后根据预配置的虚拟主机规则，将请求路由至正确的网站根目录或应用程序上下文。

# HTTP请求转发？

HTTP通信中，数据转发主要是通过各种应用程序和技术实现的，这些用于促进客户端与服务器之间的信息交换。以下是几种常见的HTTP数据转发应用程序和技术：

1. 代理服务器（Proxy Server）：

   代理服务器位于客户端和目标服务器之间，接收客户端的HTTP请求，然后代表客户端向目标服务器发起请求，并将响应再转发给客户端。它可以缓存内容、过滤请求、匿名访问等。

2. 负载均衡器（Load Balancer）：

   负载均衡器用于在多台服务器之间分配传入的网络流量，以优化资源使用、提高响应速度和避免单点故障。它接收到HTTP请求后，会根据预设策略（如轮询、最少连接数等）选择一个最佳服务器并将请求转发过去。

3. 网关（Gateway）：

   网关作为不同网络架构或协议之间的桥梁，可以接收HTTP请求并转换协议或处理特殊要求后转发给其他系统。例如，API网关常用于微服务架构中，负责请求路由、协议转换、安全控制等。

4. 反向代理（Reverse Proxy）：

   反向代理位于服务器端，对于客户端来说就像是原始服务器。它接收外部请求，然后将这些请求转发给内部网络中的一个或多个服务器。对外部用户隐藏了服务器的真实IP地址，同时可以提供缓存、SSL终止、安全防护等功能。

5. 内容分发网络（Content Delivery Network, CDN）：

   CDN是一种分布式网络服务，能够在全球范围内缓存静态内容（如图片、视频、样式表等），并根据用户的地理位置将请求重定向到最近的节点，从而减少延迟并加速内容传递。

6. 隧道技术（Tunneling）：

   在HTTP通信中，有时会使用HTTP隧道技术来封装非HTTP协议的数据，如HTTPS通过HTTP隧道穿越防火墙。这种情况下，HTTP作为一种载体，用于封装和转发其他协议的数据包。

# HTTP客户端缓存？

HTTP客户端，尤其是浏览器，使用缓存机制提高网页加载速度、减少网络带宽消耗以及提升用户体验。机制如下：

1. 缓存存储：浏览器将请求过的资源副本存放在本地的临时存储区域。
2. 缓存检查与验证：
   - 首次请求：当浏览器首次请求一个资源时，它会从服务器下载资源，并根据服务器响应中的缓存控制指令决定如何缓存该资源。
   - 后续请求：再次请求相同资源时，浏览器首先检查本地缓存，如果找到匹配的资源，则根据缓存控制策略决定是否使用缓存中的副本。
   - 验证机制：
   - 若需验证缓存资源是否仍然有效，浏览器会发送一个条件请求给服务器，携带上次下载资源时服务器提供的ETag或Last-Modified信息。服务器根据这些信息判断资源是否有变化，如果没有变化，则返回一个很小的响应（通常是304 Not Modified），指示浏览器继续使用缓存中的副本。
3. 缓存策略：
   - 强制缓存：通过指定资源的过期时间或最大生存周期，浏览器在指定时间内直接使用缓存，无需向服务器验证。
   - 对比缓存：即使资源尚未过期，浏览器也会询问服务器资源是否有更新，通过比较Etag或Last-Modified值来决定是否使用缓存。
4. 缓存协商：当缓存策略要求或缓存已过期时，浏览器与服务器间会进行协商，以确定是否使用缓存内容或获取新内容。
5. 缓存清楚：用户或开发者可以通过浏览器设置手动清除缓存，或者利用浏览器自带的清理功能自动管理缓存空间。
6. 缓存异常与问题：有时，由于缓存控制指令设置不当、浏览器实现差异或网络问题，可能会导致缓存不一致、陈旧数据展示等问题，需要通过调整服务器端配置或采取客户端措施解决。

# HTTP在安全方面有哪些弊端？

- 由于采取明文传输，报文信息可能被窃听
- 由于HTTP协议没有对双方身份进行验证，所以可能存在身份伪装的情况
- 由于报文在传输过程中可能被恶意篡改，无法确定报文的前后一致性

# HTTPS和HTTP有什么区别？

HTTPS = HTTP + 加密 + 认证 + 完整性校验

HTTP直接与传输层进行交互，而HTTPS则先与SSL/TLS进行交互，再由SSL/TLS与传输层交互。

# 什么是加密过程？两种加密方式？

加密就像是对内容上了一把锁，然后会得到一个钥匙，也就是密钥，有了密钥就能对内容解密

- 共享密钥加密（对称密钥加密）：
  - 加密和解密使用同一把密钥
  - 问题在于如何把密钥安全的送到对方手中
- 公开密钥加密（非对称密钥加密）：
  - 一把公钥，一把私钥
  - 接收方存有配对的一套密钥，然后把公钥共享，发送方使用公钥对内容加密并发送，接收方使用私钥对内容解密

# HTTPS加密方式？

HTTPS采用混合加密方式，也就是在交换密钥环节采用公开密钥方式，目的是把共享密钥成功送到对方手中。再采取共享密钥加密进行内容传输。

# 怎么保证公钥的安全传输？

1. 首先服务器运营商向数字证书认证机构（CA）提交申请，请求为服务器的一个公钥颁发一个数字证书
2. CA对申请者进行身份验证，验证通过后创建一个数字证书
3. CA使用自己的私钥对数字证书进行加密，生成一个数字签名。这个签名使得任何拥有CA公钥的实体都可以验证证书的真实性
4. CA将制作好的数字证书分发给服务器
5. 客户端验证：
   - 客户端尝试与服务器建立SSL/TLS连接，服务器会将其数字证书发送给客户端
   - 客户端使用预置的CA公钥对数字证书的数字签名做认证，从而保证服务器的公钥没有被篡改

# HTTPS通信过程？

1. 客户端向服务器发送请求，请求包含客户端支持的SSL/TLS版本和加密套件列表
2. 服务端选择双方都支持的最高版本的SSL/TLS，并将其数字证书发送给客户端，数字证书包含服务器的公钥，以及受信任的CA的签名
3. 客户端验证数字证书的有效性，验证成功后，生成一个随机的对称会话密钥，用于接下来的通信加密
4. 然后使用服务器的公钥将对称会话密钥进行加密，发送给服务器
5. 服务器使用其私钥进行解密，拿到对称会话密钥，接下来双方使用对称会话密钥进行通信

# HTTPS使用场景？

HTTPS安全可靠，但是相比HTTP而言，效率较低。所以最好在包含个人信息等敏感数据时，才利用HTTPS加密通信。

# 基于表单的用户身份验证？

基于表单的验证是一种常见的用户身份验证方法，它并不直接由HTTP协议定义，而是作为Web应用程序层面的一种实现方式。这种方式允许开发者自定义验证逻辑和用户界面。

**基本流程：**

1. 用户界面：用户访问需要认证的Web页面时，会看到一个登录表单，通常要求输入用户名和密码。这个表单是Web应用的一部分，由HTML和可能的JavaScript构成
2. 表单提交：用户填写完表单后点击提交按钮，表单数据通过HTTP POST请求发送到服务器。
3. 服务器验证：服务器端接收到请求后，会验证用户名和密码的正确性。这通常涉及查询数据库，确认用户名是否存在且对应的密码是否匹配。
4. 会话管理：
   - 成功验证后，服务器会创建一个新的会话（Session），并分配一个唯一的会话ID。
   - 这个会话ID会通过响应发送给客户端，最常见的方式是通过设置Cookie。客户端之后的每个请求都会携带这个Cookie，从而让服务器识别出已登录的用户。
5. 重定向或显示内容：验证成功后，服务器可能重定向用户到受保护的页面，或者直接返回需要保护的内容。如果验证失败，则可能重新显示登录表单，并附带错误消息。

# WebSocket？

WebSocket是一种在单个TCP连接上进行全双工通信的协议。与传统的HTTP协议相比，它解决了服务器主动向客户端推送信息的难题，实现了双方的实时通信，非常适合需要**低延迟**和**高交互性**的应用场景。

**工作原理**

1. 握手初始化：WebSocket通信开始时，首先通过HTTP请求进行握手。这个请求会包含一些特殊的头信息，比如Upgrade头部，告诉服务器希望转换到WebSocket协议。
2. 协议升级：服务器确认支持WebSocket协议后，连接升级，之后的数据交换就不再使用HTTP协议，而是直接在TCP连接上进行。
3. 数据帧传输：WebSocket使用自己的帧格式传输数据，可以发送文本或二进制数据。这种帧格式设计允许高效地进行数据传输，并且支持分片发送大数据。
4. 全双工通信：一旦连接建立，客户端和服务器都可以在任意时刻主动发送数据，无需等待对方的请求，实现了真正的双向实时通信。

# HTTP 2.0的多路复用？

HTTP/2.0的多路复用（Multiplexing）是一种改进的通信机制，它允许在一个单一的TCP连接上同时处理多个双向的数据流。

**工作原理**

1. 二进制分帧层：所有传输的数据都会被分割成更小的二进制帧，这样服务器和客户端就可以在同一个TCP连接中交错发送多个请求和响应的帧。
2. 流（Stream）：在多路复用中，每个请求或响应都被视为一个独立的流，每个流都有一个唯一的整数标识符。这些标识符使得接收方能够重新组装收到的帧，正确地将它们关联到各自的请求或响应上。
3. 优先级和依赖：HTTP/2允许为每个流设置优先级，这样客户端可以指示哪些资源更重要，服务器可以根据这些优先级来调度数据的发送顺序。此外，流还可以声明对其他流的依赖关系，进一步细化数据的传输优先级。
4. 消除队头阻塞：由于多个请求和响应可以同时在一个连接上交错传输，即使某个响应延迟，也不会阻塞其他请求的处理，大大提高了页面加载效率。
