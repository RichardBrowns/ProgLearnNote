# Java概述

## Java有哪些优点？

- 跨平台特性：JVM在不同的操作系统中都有实现，只要在操作系统上装了JVM，就可以保证一个Java程序在不同的操作环境下都可以执行
- 自动内存管理：Java具有自动内存管理机制，避免手动管理，降低内存泄漏的风险，简化开发，使得程序更加健壮
- 标准库十分丰富：涵盖数据结构、I/O、多线程、网络编程等多个方面
- 强类型语言和异常处理机制：类型检查严格，异常处理完整，增强了代码的可靠性和安全性
- 生态强大和使用广泛：丰富的第三方框架，Spring家族，Apache Commons等等

## JVM、JRE、JDK有什么区别？

- JVM是Java的虚拟机，负责执行编译后的Java字节码
- JRE是Java的运行时环境，包含JVM和运行时需要的核心类库
- JDK包含JRE和javac、javadoc等开发工具，更加完整

## 什么是字节码，有什么用？

字节码，是.java文件经过编译后生成的.class文件，可以被虚拟机识别，并解释执行，从而实现Java的跨平台特性。

Java程序的执行过程主要有：

1. 编译：将代码(.java)编译成虚拟机可以识别理解的字节码(.class)
2. 解释：虚拟机解释字节码，生产操作系统可直接执行的机器码
3. 执行：机器执行二进制机器码

## JIT即时编译？

JIT即时编译器是存在是为了增强Java代码的执行效率，Java字节码解释的方式是不如C++编译成机器码执行的效率的。所以在一个Java程序执行开始，首先采用解释器模式执行Java字节码，在这过程中JIT编译器会实时监控Java程序的执行情况，识别出热点代码，并将其编译成本地机器码和进行各种优化，从而提升程序执行效率。

# 基础语法

## Java有哪些数据类型？

- 基本数据类型
  - boolean，默认false，大小因虚拟机实现而定
  - char，默认'\n0000'，2字节
  - byte，默认0，1字节
  - short，默认0，2字节
  - int，默认0，4字节
  - long，默认0L，8字节
  - float，默认0.0f，4字节
  - double，默认0.0，8字节
- 引用数据类型
  - 类，Class
  - 接口，interface
  - 数组，[]

## 基本数据类型-自动转换与强制转换？

**自动转换（隐式转换）**

规则：

- 范围较小的类型可以自动转换为范围较大的类型
- 没有数据丢失风险

转换顺序：

- byte -> short -> int -> long -> float -> double
- char -> int -> long -> float -> double

**强制转换（显式转换）**

规则：

- 需要显式地指定转换类型
- 可能造成数据丢失或精度降低

```
目标类型 变量名 = (目标类型) 值;
```

## 自动拆箱与装箱？

- **装箱：**将基本数据类型转换为对应的包装类型
- **拆箱：**将包装类型转换为基本数据类型

## 包装类的常量池？

常量池是JVM的一种优化机制，用于缓存常用的对象实例，避免对象频繁的创建和销毁，从而提升性能和节省内存。

**包装类的常量池**

- **Integer：**缓存-128~127的整型对象
- **Boolean：**缓存true和false实例
- **Character：**缓存\u0000~\u007F的字符对象
- **Byte：**缓存-128~127的所有字节对象
- **Short和Long：**也缓存-128~127的数值对象
- 浮点数没有对应的常量池

常量池的工作机制主要依赖于自动装箱（Autoboxing）和自动拆箱（Unboxing）。当你使用基本类型和包装类进行赋值或比较时，Java编译器会自动在基本类型和包装类之间进行转换。

## &和&&的区别？

- &是逻辑与，两边的表达式都会计算，全部为true时通过
- &&是短路与，先计算左边，如果左边是false，直接拒绝；同样两边都是true时通过

在做对象判空时要使用&&，比如`username != null &&!username.equals("")`，如果使用逻辑与，会造成空指针异常

***注意**：逻辑或（|）与短路或（||）的差别也是如此*

## switch语法支持哪些类型？

1. 整数类型：
   - byte
   - short
   - int
   - char
2. 枚举类型：
   - enum
3. 字符串类型：
   - String
4. 包装类型：
   - Byte
   - Short
   - Integer
   - Character

需要注意的是，`long`、`float`、`double`以及其他非整数类型（如`boolean`）不能用于`switch`语句。

## 什么是枚举类型？

Java中的枚举类型（`enum`）是一种特殊的数据类型，它允许一个变量只能是预定义的常量集合中的一个。用于表示一组固定的常量值，如一周中的七天、颜色、方向等。

枚举类型使用`enum`关键字定义。如：

```java
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
}
```

枚举不仅仅是简单的常量集合，它还可以包含构造函数、字段和方法。例如：

```java
public enum Day {
    SUNDAY("Weekend"), MONDAY("Weekday"), TUESDAY("Weekday"), 
    WEDNESDAY("Weekday"), THURSDAY("Weekday"), FRIDAY("Weekday"), 
    SATURDAY("Weekend");

    private String typeOfDay;

    private Day(String typeOfDay) {
        this.typeOfDay = typeOfDay;
    }

    public String getTypeOfDay() {
        return this.typeOfDay;
    }
}
```

枚举可以覆盖`toString()`方法来提供更友好的输出：

```java
public enum Day {
    SUNDAY("Weekend"), MONDAY("Weekday"), TUESDAY("Weekday"), 
    WEDNESDAY("Weekday"), THURSDAY("Weekday"), FRIDAY("Weekday"), 
    SATURDAY("Weekend");

    private String typeOfDay;

    private Day(String typeOfDay) {
        this.typeOfDay = typeOfDay;
    }

    public String getTypeOfDay() {
        return this.typeOfDay;
    }

    @Override
    public String toString() {
        return this.name() + " (" + this.typeOfDay + ")";
    }
}
```

枚举类型提供一些有用的静态方法：

- `values()`: 返回所有枚举常量的数组。
- `valueOf(String name)`: 根据名称返回对应的枚举常量。

## break，continue，return的用法和区别？

- break表示结束当前循环体
- continue表示结束本次循环，进行下一次循环
- return表示结束当前的方法，直接返回

## 什么是位运算？

位运算是直接对整数的二进制位进行操作的一种运算方式，效率较高。

- 左移运算符，<<：将一个二进制数的所有位向左移动若干位，右侧用0填充。左移一位相当于乘以2。
- 右移运算符，>>：将一个二进制数的所有位向右移动若干位，左侧用符号位填充。右移一位相当于除以2。
- 无符号右移运算符，>>>：将一个二进制数的所有位向右移动若干位，左侧用0填充，不考虑符号位。

## 自增/自减运算符？

在Java中，自增（`++`）和自减（`--`）运算符用于对变量进行增减操作。它们可以分别将变量的值增加或减少1。

- 前缀自增（`++variable`）和前缀自减（`--variable`）运算符首先对变量进行增减操作，然后再使用该变量的值。
- 后缀自增（`variable++`）和后缀自减（`variable--`）运算符首先使用变量的当前值，然后再对变量进行增减操作。

注意，这不是原子操作，所以如果在并发编程的环境下，要做进一步处理

## float怎么表示小数？

单精度浮点数使用 32 位（二进制位）来表示一个浮点数，这 32 位分为三个部分：

1. **符号位（Sign bit）**：1 位
2. **指数位（Exponent）**：8 位
3. **尾数位（Mantissa or Fraction）**：23 位

**1. 符号位（Sign bit）**

- 1 位，用于表示数的正负。
  - 0 表示正数
  - 1 表示负数

**2. 指数位（Exponent）**

- 8 位，用于表示指数部分。为了表示负指数，使用偏移量（bias）的方法。
  - 对于单精度浮点数，偏移量（bias）是 127。
  - 实际存储的指数值 = 指数 + 偏移量（127）

**3. 尾数位（Mantissa or Fraction）**

- 23 位，用于表示尾数（也称为有效数字）。
  - 尾数是一个二进制小数，隐含了一个前导的 1（即规范化形式）。
  - 实际存储的尾数是去掉这个前导的 1 的部分。

## 高精度浮点数？

有些业务对数值的精确度要求很高，所以可以使用BigDecimal类，这是因为 `BigDecimal` 提供了任意精度的十进制数表示，并且具有精确的舍入控制。

# 面向对象

## 面向过程与面向对象的区别？

- **面向过程**：分析出解决问题的步骤，使用函数实现一个个步骤，再从主函数开始进行链式调用
- **面向对象**：将遇到的问题构建为类和对象，描述其特征和行为，更接近日常思维，代码重用率更高。

## 封装、继承、多态？

- **封装：**封装是指将数据和行为的实现隐藏起来，限制外部对数据的直接访问，通过公共接口来操作对象的属性，从而提升代码的安全性和可维护性
- **继承：**继承允许一个类继承另一个类的属性和方法，从而实现代码复用和扩展。子类可以继承父类的功能，还可以增加新的功能或重写父类的方法。
- **多态：**多态性允许不同类的对象通过相同的接口调用，而不需要知道具体对象的类型。多态可以通过方法重载（同一类中方法名相同但参数不同）和方法重写（子类重写父类的方法）来实现，使得程序更加灵活和可扩展。

## 重载和重写的区别？

- **重载：**重载是指在同一个类，多个方法的名字相同，参数列表不同，目的是为了一个方法可以对不同的输入，做不同的输出
- **重写**：重写是指子类重写父类的方法，方法名、参数列表和返回值都一样，目的是为了在子类中提供特定的实现，以取代父类的实现。

## default、public、protected、private区别？

- default：表示同包可见
- private：同一类可见，不可修饰类和接口
- public：所有类可见
- protected：同包和子类可见，不可修饰类和接口

## this关键字？

this是一个引用，指向当前对象。所以可以使用它调用本对象的构造方法、属性和函数。

## 抽象类和接口的区别？

在Java中采用单继承机制，只可以继承一个类，但是可以实现多个接口。抽象类是is-a的语义，接口是has-a的语义。所以一个类要序列化，只要实现Serializable接口即可。抽象类更多的是为多个类提供共同的状态和行为。而接口则是定义了一组行为。

- 抽象类可以有自己的构造函数、变量、具体方法和抽象方法
- 接口没有自己的构造函数和变量，可以有常量，可以有方法签名和默认实现

## 成员变量和局部变量的区别？

- **成员变量**：成员变量属于对象的变量，至少在类内可见，生命周期与对象一致，有自己的默认值，和对象一道存在堆区，可以使用访问修饰符修饰
- **局部变量**：局部变量是方法、代码块的变量，作用域在方法和代码块以内，生命周期也是，存储在栈区

## 静态变量和实例变量？静态方法和实例方法？

- 静态变量，被static修饰，属于类，不同的对象共享这一个变量，在类加载时就存在
- 实例变量，依附于对象，通过对象进行访问
- 静态方法，也叫类方法，可以通过类名.方法名访问
- 实例方法，属于对象，通过对象名.方法名访问

## final关键字的作用？

- final作用于类时，表示该类不能被继承
- final作用于变量时，表示变量不能修改
- final作用于方法时，表示不能够重写

## == 和 equals()的区别？

- ==用于基本数据类型的比较，是比较变量的值
- ==用于引用数据类型的比较，是比较引用地址是否相等
- equals()方法一般表示两个对象的内容是否相等，属于Object的方法，默认和==相同，所以很多时候要按照自己的需要重写

## hashCode()和equals()?

**equals()方法**

`equals()`方法用于比较两个对象内容是否相等。默认情况下，`Object`类的`equals()`方法是比较对象的引用是否相同，即两个对象是否是同一个实例。然而，在实际应用中，我们通常需要比较对象的内容是否相等，因此需要重写`equals()`方法。

**hashCode()方法**

`hashCode()`方法返回对象的哈希码。哈希码是一个整数，用于支持基于哈希表的集合（如`HashMap`、`HashSet`等）。`Object`类的默认实现是基于对象的内存地址计算哈希码。

**equals()和hashCode()的关系**

- 如果两个对象根据`equals(Object)`方法是相等的，那么它们的`hashCode()`方法必须返回相同的整数。
- 如果两个对象根据`equals(Object)`方法是不相等的，它们的`hashCode()`方法可以返回相同的整数（但这样会降低哈希表的性能）。

## 参数传递机制？

Java采用值传递，不管是基础类型还是引用类型，传的都是值，方法拿到的是值的拷贝。

## 深拷贝和浅拷贝？

两者的区别主要在于当对象的成员变量是引用类型时，浅拷贝是拷贝的引用，所以两个对象共享一个成员对象；而深拷贝则会创建一个和之前一模一样的成员对象，再引用它。

## 创建对象的几种方式？

- new关键字创建

  ```java
  Person person = new Person();
  ```

- 反射机制创建

  ```java
  Class clazz = Class.forName("Person");
  Person person = (Person) clazz.newInstance();
  ```

- clone拷贝

  ```java
  Person person = new Person();
  Person person2 = (Person) person.clone();
  ```

- 序列化机制创建

  ```java
  Person person = new Person();
  ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.txt"));
  oos.writeObject(person);
  ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.txt"));
  Person person2 = (Person) ois.readObject();
  ```

## 子父类静态代码块和构造方法执行顺序？

1. **父类的静态代码块**（只执行一次，在类加载时执行）
2. **子类的静态代码块**（只执行一次，在类加载时执行）
3. **父类的实例代码块**（每次创建对象时执行）
4. **父类的构造方法**（每次创建对象时执行）
5. **子类的实例代码块**（每次创建对象时执行）
6. **子类的构造方法**（每次创建对象时执行）

# 集合框架

# 异常处理

# I/O

# 多线程