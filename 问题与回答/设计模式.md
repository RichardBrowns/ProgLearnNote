# 设计模式之简单工厂模式？

**原理：**

简单工厂模式是一种创建型设计模式，它将对象的创建逻辑封装在一个工厂类中。客户端不直接创建对象，而是通过调用工厂类的方法来获取所需的对象。这样可以将对象的创建与使用分离，提高代码的灵活性和可维护性。

**实现：**

```java
// 1、定义一个接口或抽象类
interface Product{
    void operation();
}

// 2、实现具体的产品类
class ConcreteProductA implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductA operation");
    }
}

class ConcreteProductB implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductB operation");
    }
}

// 3、创建工厂类
class SimpleFactory{
    public static Product createProduct(String type){
        if("A".equals(type)){
            return new ConcreteProductA();
        }else if("B".equals(type)){
            return new ConcreteProductB();
        }
        return null;
    }
}

// 4、使用
public class Main{
    public static void main(String[] args) {
        Product productA = SimpleFactory.createProduct("A");
        productA.operation();

        Product productB = SimpleFactory.createProduct("B");
        productB.operation();
    }
}
```

**应用场景与好处：**

1. 降低系统耦合度
   - 封装对象创建逻辑，客户端无需直接实例化具体类
   - 客户端只需知道产品接口，不依赖具体实现
   - 偏于统一管理对象创建过程
2. 提高代码可维护性和扩展性
   - 集中管理对象创建，便于统一修改和维护
   - 添加新产品只需修改工厂类，客户端代码无需改动
   - 可以在工厂中添加额外控制逻辑，如对象池管理
3. 适用于特定场景
   - 适合产品类型相对固定、变化不频繁的情况
   - 对象创建逻辑复杂时，可以简化客户端代码
   - 需要对客户端隐藏产品实现细节的场景

# 设计模式之工厂方法模式？

工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它定义了一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类中进行，从而为创建对象提供了一种更灵活的方式。

**原理**

工厂方法模式主要包括以下几个角色：

- 工厂接口：这是工厂方法模式的核心，它声明了一个创建对象的方法，但不涉及具体的对象创建过程。这个接口使得子类可以决定要实例化的具体产品类。
- 具体工厂：实现了工厂接口，负责实例化具体的对象。每个具体工厂都对应一种具体的产品，并实现工厂接口中的方法以创建该类型的产品。
- 产品接口：定义了产品的接口，声明了所有具体产品类共有的操作或属性。这样，客户端可以使用产品接口来操作任何具体的产品对象，而不需要知道其具体的类。
- 具体产品：实现了产品接口，每一个具体产品都是工厂方法的一个可能返回值。具体产品类代表了可以被创建的各种具体对象。

**工作流程**

1. 客户端调用具体工厂的工厂方法请求创建产品对象。
2. 具体工厂根据请求创建对应的具体产品对象，这个过程可以是静态的（即总是创建同一类型的产品），也可以是动态的（根据条件创建不同类型的产品）。
3. 工厂方法将新创建的具体产品对象返回给客户端，而客户端无需关心产品的具体创建细节，只需要通过产品接口来使用这个对象即可。

**实现**

```java
// 1、定义一个接口或抽象类
interface Product{
    void operation();
}

// 2、实现具体的产品类
class ConcreteProductA implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductA operation");
    }
}

class ConcreteProductB implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductB operation");
    }
}

// 3、定义抽象工厂
interface Factory{
    Product createProduct();
}

// 4、定义具体的工厂类
class ConcreteFactoryA implements Factory {
    public Product createProduct() {
        return new ConcreteProductA();
    }
}

class ConcreteFactoryB implements Factory {
    public Product createProduct() {
        return new ConcreteProductB();
    }
}

// 5、使用
public class Main{
    public static void main(String[] args) {
        Factory factory = new ConcreteFactoryA();
        Product product = factory.createProduct();
        product.operation();
    }
}
```

**优点**

- 遵循开闭原则：新增产品类型时，只需增加新的具体产品类和对应的工厂子类，无需修改现有代码，增强了系统的扩展性。
- 解耦：客户端与具体产品类解耦，客户端仅依赖于产品接口和工厂接口，使得系统更易于维护和扩展。
- 灵活性高：可以灵活应对需求变化，通过配置不同的具体工厂，可以在运行时决定创建哪种产品对象。

**缺点**

- 需要为每种产品创建一个具体工厂类，增加了类的数量，可能导致系统结构复杂化。
- 在产品等级结构变化较大时，可能需要较多的适配工作。

**应用场景**

- 当一个类不知道它所需要的对象的类时
- 当一个类希望由其子类来指定它所创建的对象时
- 当类将创建对象的职责委托给多个帮助子类中的某一个,并且你希望将哪一个帮助子类是代理者这一信息局部化时
- 在需要管理产品族时,特别是当产品有多个系列时
- 在框架开发中,可以让框架用户通过子类化来定制和扩展框架的功能

# 设计模式之抽象工厂模式？

抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个接口，用于创建一系列相关或相互依赖的对象，而无需指定这些对象的具体类。此模式的主要优势在于它能够帮助系统解耦，使得客户端代码可以从具体的类中独立出来，仅依赖于抽象接口。

**原理**

抽象工厂模式的核心在于定义一个抽象工厂类，这个类声明了一系列的抽象方法，每一个方法都对应于产品族中的一个产品。产品族指的是由同一个工厂生产的、位于不同产品等级结构中的一组产品。例如，一个品牌下的不同产品线，如手机、电脑、音响等。

**主要角色**

1. 抽象工厂：定义一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们的具体类。
2. 具体工厂：实现了抽象工厂接口，负责创建具体的产品对象。
3. 抽象产品：定义了产品对象的公共接口，是产品等级结构的基类。
4. 具体产品：实现了抽象产品接口，是具体工厂生产的实际对象。

**工作流程**

1. 客户端请求一个产品族的对象。
2. 客户端通常只和抽象工厂接口交互，而不直接和具体工厂或具体产品类交互。
3. 抽象工厂根据请求，返回一个具体产品对象的实例。
4. 如果需要，抽象工厂会协调创建同一产品族的其他相关对象。

**实现**

```java
// 抽象产品A
interface AbstractProductA{
    void operationA();
}

// 抽象产品B
interface AbstractProductB{
    void operationB();
}

// 具体产品 A1
class ConcreteProductA1 implements AbstractProductA {
    public void operationA() {
        System.out.println("ConcreteProductA1 operationA");
    }
}

// 具体产品 A2
class ConcreteProductA2 implements AbstractProductA {
    public void operationA() {
        System.out.println("ConcreteProductA2 operationA");
    }
}

// 具体产品 B1
class ConcreteProductB1 implements AbstractProductB {
    public void operationB() {
        System.out.println("ConcreteProductB1 operationB");
    }
}

// 具体产品 B2
class ConcreteProductB2 implements AbstractProductB {
    public void operationB() {
        System.out.println("ConcreteProductB2 operationB");
    }
}

// 抽象工厂
interface AbstractFactory{
    AbstractProductA createProductA();
    AbstractProductB createProductB();
}

// 具体工厂 1
class ConcreteFactory1 implements AbstractFactory {
    public AbstractProductA createProductA() {
        return new ConcreteProductA1();
    }
    public AbstractProductB createProductB() {
        return new ConcreteProductB1();
    }
}

// 具体工厂 2
class ConcreteFactory2 implements AbstractFactory {
    public AbstractProductA createProductA() {
        return new ConcreteProductA2();
    }
    public AbstractProductB createProductB() {
        return new ConcreteProductB2();
    }
}

public class Main{
    public static void main(String[] args) {
        AbstractFactory factory1 = new ConcreteFactory1();
        AbstractProductA productA = factory1.createProductA();
        AbstractProductB productB = factory1.createProductB();
    }
}
```

抽象工厂模式特别适合于需要创建一系列相互关联或相互依赖的对象群的场景。它提供了一种将一组对象的实现细节与它们的一般使用分离的方法。

# 设计模式之单例模式？

单例模式是一种创建型设计模式，它保证一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。这种模式通常用于那些在整个系统中只需要一个实例的场景，比如配置管理器、日志记录器等。

**原理**

1. 私有化构造函数：为了防止其他对象实例化单例类，构造函数必须被声明为`private`，这样从外部无法通过`new`关键字创建新的实例。
2. 静态成员变量：单例类包含一个静态成员变量，用于存储该类的唯一实例。这是因为静态成员在类加载时初始化，且在所有实例间共享，保证了单例性。
3. 提供静态访问方法：单例类提供一个静态方法（通常是`getInstance()`），用于返回唯一的实例。这个方法会在第一次调用时创建实例，并在后续调用中返回已创建的实例。

**常见实现**

```java
// 饿汉式：在类加载时创建实例，可能造成资源浪费
class Singleton{
    private static final Singleton instance = new Singleton();

    private Singleton{}

    public static Singleton getInstance(){
        return instance;
    }
}

// 懒汉式：在第一次调用getInstance()时创建实例，节省资源，但是需要同步机制保证线程安全
class Singleton{
    private static Singleton instance;

    private Singleton{}

    public static synchronized Singleton getInstance(){
        if(instance == null)
            instance = new Singleton();
        return instance;
    }
}

/**
 * 双重检查锁定：
 * 1、volatile保证原子性和可见性
 * 2、synchronized (Singleton.class) 表示使用类对象作为锁对象，确保同一时间只有一个线程可以执行被同步的代码块
 * 3、外层检查是避免每次线程都获取锁，提升性能
 * 4、内层检查是为了保证正确的初始化，避免对象创建了，其他线程却以为对象还没创建
 */
class Singleton{
    private volatile static Singleton instance;

    private Singleton{}

    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

/**
 * 静态内部类：利用Java的类加载机制保证初始化时的线程安全，避免了显式的同步。
 * 类加载过程是线程安全的，并且静态内部类只有被显式引用的时候才会被加载。
 *  */ 
class Singleton{
    private Singleton(){}

    private static class SingletonHolder{
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}

// 枚举方式：线程安全，性能较好
enum Singleton{
    INSTANCE;
}
```

推荐使用枚举类型，但是需要延迟加载或需要在单例中执行一些复杂的初始化逻辑，那么使用静态内部类实现可能更为适合。

# 设计模式之原型模式？

原型模式是一种创建型设计模式，它使用已有的对象实例作为原型，通过复制（浅复制或深复制）这些原型来创建新的对象。这种模式可以避免创建对象时的重复初始化操作，从而提高性能和效率。

**原理**

在原型模式中，一个类实现了`clone()`方法，这个方法用于创建一个与原对象相同的新对象。通常，这个方法是在`Cloneable`接口中定义的，但Java 10之后，由于`clone()`方法的不安全性和其他原因，推荐使用更安全的克隆方法，如自定义的`copy()`方法或者使用序列化反序列化等技术。

**UML图**

```plaintext
+----------------+        +-----------------+
|    Prototype   |        |     Concrete    |
|                |        |      Prototype  |
| - clone():this |--------| - clone():this  |
+----------------+        +-----------------+
```

**实现**

```java
// 定义一个接口或抽象类
public interface Prototype<T> extends Cloneable{
    T clone();
}

// 具体的原型类
public class ConcretePrototype implements Prototype<ConcretePrototype> {

    private String id;
    private String value;

    public ConcretePrototype(String id, String value) {
        this.id = id;
        this.value = value;
    }

    @Override
    public ConcretePrototype clone() {
        try {
            return (ConcretePrototype) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }

    // 省略getters和setters
}

// 使用示例
public class Client {
    public static void main(String[] args) {
        ConcretePrototype prototype = new ConcretePrototype("1", "Hello");
        ConcretePrototype clonedPrototype = prototype.clone();

        System.out.println(prototype);
        System.out.println(clonedPrototype);
    }
}
```

**注意事项**

1. 浅拷贝 / 深拷贝：浅复制仅仅复制了对象的引用，而深复制则会复制对象的所有属性，包括嵌套的对象。在处理包含复杂数据结构的对象时，深复制可能是必要的。
2. 性能问题：频繁调用`clone()`方法可能会导致性能下降，尤其是在对象很大或者包含大量计算的情况下。
3. 安全性：直接使用`clone()`方法可能不安全，因为它可以被任何类访问，可能导致对象状态的意外修改。因此，建议在子类中将`clone()`方法声明为`protected`，并在需要的地方提供安全的公共克隆方法。

原型模式适用于对象创建成本较高且需要频繁创建相似对象的场景。

# 设计模式之代理模式？

# 设计模式之观察者模式？

观察者模式是一种行为设计模式，它定义了对象之间一对多的依赖关系，让多个观察者对象能够自动地、实时地响应一个主题对象（也称为被观察对象）的状态变化。这种模式促进了对象之间的松耦合，使得系统易于扩展和维护。

**核心概念包括：**

- **Subject（主题/被观察者）：**管理一系列依赖于它的观察者对象，并提供接口给这些观察者注册自己或取消注册。当主题的状态发生改变时，它会通知所有已注册的观察者。
- **Observer（观察者）：**定义了一个更新接口，当主题状态变化时，该接口会被主题调用来通知观察者。观察者可以根据需要实现这个接口来更新自己的状态。

**工作流程：**

1. **订阅（Attach）：**观察者向主题注册。
2. **通知（Notify）：**当主题状态发生变化时，它遍历所有注册的观察者，调用它们的更新方法。
3. **更新（Update）：**每个观察者根据接收到的通知执行相应的操作，即更新自身的状态以反映主题的变化。

**优点：**

- **松耦合：**观察者和被观察者之间仅通过接口相互通信，降低了模块间的耦合度。
- **灵活性：**可以轻松添加新的观察者，无需修改现有代码。
- **广播通信：**一个主题状态的改变可以自动通知到所有相关的观察者，简化了对象之间的交互。

**应用场景：**

- 事件处理系统，如按钮点击监听。
- 实时数据更新，如股票价格、气象信息的推送。
- 用户界面更新，如MVC（模型-视图-控制器）架构中的视图更新。
- 日志记录、通知服务等。

**代码实现：**

```java
//定义Subject接口，声明添加、删除观察者以及通知所有观察者的方法：
interface Subject{
    void addObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

//创建具体的ConcreteSubject实现Subject接口，维护一个观察者列表，并在状态改变时通知它们
class ConcreteSubject implements Subject{
    private List<Observer> observers = new ArrayList<>();
    private String state;
    
    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
        // 状态改变时，通知所有观察者
        notifyObservers();
    }
    
    @Override
    void addObserver(Observer observer){
        observers.add(observer);
    }
    
    @Override
    void removeObserver(Observer observer){
        observers.remove(observer);
    }
    
    @Override
    public void notifyObservers(){
        for (Observer observer : observers) {
            observer.update(this);
        }
    }
}

//定义Observer接口，声明更新时需要执行的方法
interface Observer{
    void update(Subject subject);
}

//创建具体的观察者类，实现Observer接口
class ConcreteObserver implements Observer{
    private String name;
    private ConcreateSubject subject;
    
    public ConcreteObserver(String name, ConcreteSubject subject) {
        this.name = name;
        this.subject = subject;
        subject.addObserver(this); // 在构造函数中订阅主题
    }
    
    @Override
    public void update(Subject subject) {
        ConcreteSubject concreteSubject = (ConcreteSubject) subject;
        System.out.println(name + " received: " + concreteSubject.getState());
    }
}

//在主方法中创建主题和观察者，并演示观察者模式的工作流程
public class ObserverPatternDemo {
    public static void main(String[] args) {
        ConcreteSubject subject = new ConcreteSubject();

        Observer observer1 = new ConcreteObserver("Observer 1", subject);
        Observer observer2 = new ConcreteObserver("Observer 2", subject);

        subject.setState("State changed to something interesting");
    }
} 
```

