# Git

https://bingohuang.gitbooks.io/progit2/content/01-introduction/sections/about-version-control.html

# Maven

https://blog.csdn.net/luanlouis/article/details/50492163

# XML

**什么是XML？**

可扩展标记语言 (XML) 允许您以可共享的方式定义和存储数据。XML 支持计算机系统（如网站、数据库和第三方应用程序）之间的信息交换。预定义的规则简化了在任何网络上以 XML 文件的形式传输数据的过程，接收者可以使用这些规则准确高效地读取数据。

# Linux

# Docker

# PostMan

Postman 是一款功能强大的 API 开发工具，主要功能包括：

1. **发送请求**: 允许用户发送各种类型的 HTTP 请求，如 GET、POST、PUT、DELETE 等，以测试和调试 API。
2. **创建和管理请求集合**: 用户可以将相关请求组织成集合，便于管理和分享。
3. **测试和断言**: 提供了测试脚本的编写和运行功能，可以对请求的响应进行自动化测试，并根据预期结果做出断言。
4. **环境管理**: 允许用户定义不同的环境（如开发、测试、生产环境），并在请求中使用环境变量，方便在不同环境间切换。
5. **自动化集成测试**: 提供了集成测试功能，可以将多个请求组合成测试用例，并自动运行这些测试用例，验证整个 API 的功能和性能。
6. **监视和调试**: 用户可以查看请求和响应的详细信息，包括请求头、响应头、请求体和响应体等，方便调试和排查问题。
7. **Mock 服务器**: 允许用户创建虚拟的 Mock 服务器，模拟 API 的行为，方便前端和后端并行开发。
8. **协作和分享**: 提供了团队协作和分享功能，可以将请求集合和测试用例分享给团队成员，方便协作开发和测试。



# 常用类库

## Apache Common包

Apache Commons 是一个由Apache软件基金会维护的项目，旨在提供一系列高质量、可重用的Java组件，这些组件补充了Java标准库的功能。Apache Commons包含了许多子项目，每个子项目专注于解决特定的编程任务。以下是一些知名的Apache Commons包的简要介绍：

1. **Commons Lang**:
   - 提供了一系列高级的字符串处理、数学运算、日期和时间操作、反射辅助工具等。
2. **Commons Collections**:
   - 扩展了Java集合框架，提供了更多的集合实现，如双向映射、多值映射、堆栈和队列等。
3. **Commons BeanUtils**:
   - 为JavaBeans提供了一些便利的方法，如属性的自动设置和获取，以及基于属性名的复制功能，使用反射来操作Bean的getter和setter方法。
4. **Commons IO**:
   - 提供了文件操作、输入输出流、字符集转换、线程安全的I/O操作等实用工具。
5. **Commons Codec**:
   - 包含了各种编码和解码的工具，如Base64、URL编码、Hex编码等。
6. **Commons Net**:
   - 提供了网络编程的各种工具类，如FTP、SMTP、 Telnet客户端等。
7. **Commons DBUtils**:
   - 为数据库操作提供了一个简单的抽象层，简化了JDBC的使用，减少了数据库操作中的错误。
8. **Commons CLI**:
   - 用于解析命令行参数，提供了一个灵活的命令行选项解析库。
9. **Commons Configurations**:
   - 提供了读取和处理配置文件的工具，支持多种格式如XML、INI等。
10. **Commons JXPath**:
    - 提供了在Java对象图上进行导航和操作的API，类似于XPath在XML文档中的作用。
11. **Commons Math**:
    - 提供了数值计算和数学运算的工具，包括线性代数、随机数生成、统计计算等。

这些包以及其他许多子项目，都是为了简化开发者的工作，提高代码的可读性和可维护性，减少重复的代码编写。由于这些组件经过广泛的测试和社区的验证，它们通常被认为是可靠的和稳定的。

## Spring常用工具类

Spring框架提供了许多实用的工具类，它们在开发过程中可以极大地提高效率和代码质量。以下是一些Spring框架中常用的工具类，它们通常位于`org.springframework.util`包下：

1. **ClassUtils**:
   - 提供了关于类和类加载器的通用操作，如判断类是否存在、获取类的全限定名等。
2. **StringUtils**:
   - 字符串处理工具类，提供了一些常见的字符串操作，如检查空值、分割字符串等。
3. **ArrayUtils**:
   - 数组操作工具类，用于处理数组的添加、删除、合并等。
4. **ObjectUtils**:
   - 对象工具类，提供了对象的比较、空值检查、对象数组的处理等。
5. **CollectionUtils**:
   - 集合操作工具类，提供了集合的合并、分割、查找等方法。
6. **DigestUtils**:
   - 提供了各种摘要算法，如MD5、SHA等，用于数据的加密和验证。
7. **ReflectionUtils**:
   - 反射工具类，用于方便地操作类、方法和字段，包括查找方法、获取类信息等。
8. **Assert**:
   - 断言工具类，用于在代码中添加条件检查，帮助发现和预防错误。
9. **MethodInvoker** 和 **MethodUtils**:
   - 动态调用方法的工具，用于执行目标对象的指定方法。
10. **BeanUtils**:
    - 提供了JavaBean属性的复制功能，可以在对象之间复制属性值。
11. **AnnotationUtils**:
    - 注解处理工具，可以查找和处理类、方法、字段上的注解信息。
12. ** concurrency** 包下的工具类：
    - 提供了线程安全的工具，如`ConcurrentReferenceHashMap`等。

这些工具类在实际开发中非常实用，它们可以帮助简化代码，减少错误，并提高代码的可读性和可维护性。在Spring Boot中，这些工具类通常已经包含在默认的依赖中，可以直接使用。

## JSON类库

JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。尽管它的名字中含有JavaScript，但实际上JSON独立于任何语言，几乎所有的编程语言都有解析JSON数据的能力。JSON主要用来在客户端和服务端之间传输数据，比如网页浏览器和服务器之间的数据交换。

### JSON的基础结构

JSON主要有两种结构：对象（Object）和数组（Array）。

**对象（Object）**

- 由花括号 `{}` 包围，包含零个或多个键值对（key-value pairs）。
- 键必须是字符串，且在同一个对象内必须唯一；值可以是任何有效的JSON数据类型（字符串、数字、布尔值、数组、对象、null）。
- 键值对之间用逗号 `,` 分隔。

示例：

```json
{
  "name": "Alice",
  "age": 30,
  "isStudent": false
}
```

**数组（Array）**

- 由方括号 `[]` 包围，包含有序的值列表。
- 数组中的元素可以是任何有效的JSON数据类型，包括其他数组或对象。
- 元素之间也用逗号 `,` 分隔。

示例：

```json
[1, "text", true, ["subarray"], {"key": "value"}]
```

### JSON的数据类型

JSON支持以下几种数据类型：

- **字符串（String）**：必须用双引号 `"` 包围。
- **数字（Number）**：可以是整数或浮点数，不区分整型和浮点型。
- **布尔值（Boolean）**：`true` 或 `false`。
- **数组（Array）**：如前所述。
- **对象（Object）**：如前所述。
- **null**：表示空值。

### JSON的使用场景

- **Web服务**：前后端数据交互，如Ajax请求的数据格式。
- **配置文件**：轻量级的配置信息存储。
- **数据存储**：如某些数据库（如MongoDB）直接使用JSON格式存储数据。
- **移动应用**：原生应用与服务器间的数据交换。

### JSON解析与生成

大多数编程语言都有内置或第三方库来解析和生成JSON。例如，在JavaScript中可以直接使用`JSON.parse()`将JSON字符串转换为JavaScript对象，使用`JSON.stringify()`将对象转换为JSON字符串。其他语言也有类似的库或函数来处理JSON数据。

## 日志类库

Java日志库用于在程序运行时记录信息，帮助开发者诊断问题、跟踪性能和记录关键操作。

### 日志系统（日志框架/实现）

日志系统，也称为日志框架或日志实现。是具体负责生成、处理、格式化和输出日志信息的库。它们提供了日志记录的实际机制，包括但不限于日志级别的设置、日志消息的格式化、日志输出目的地（控制台、文件、数据库、网络等）的配置。常见的日志系统包括：

1. Java Util Logging (JUL)：
   - 它是Java平台的标准日志API，自Java 1.4起就内置在JDK中。
   - 简单易用，但功能相对有限，可配置性较低。
   - 支持日志级别，如SEVERE, WARNING, INFO, CONFIG, FINE, FINER, 和 FINEST。
2. Log4j：
   - 由Apache软件基金会开发，是Java社区广泛使用的日志库。
   - 功能强大，可配置性高，支持自定义日志输出格式、多种Appenders（如文件、控制台、网络等）。
   - 使用灵活，有丰富的过滤器和布局选项。
3. Logback：
   - 由Log4j的创始人设计，作为Log4j的替代品。
   - 性能优于Log4j，提供更高级别的配置和控制。
   - 支持异步日志记录，提高了日志处理的效率。
4. Log4j2：
   - Log4j的升级版本，针对性能和功能进行了优化，支持更多的现代特性。

**Log4j vs Logback vs Log4j2**

- 性能：如果性能是首要考虑，Log4j2可能是最佳选择。
- 安全性：Log4j2针对安全进行了优化，更适合对安全性要求较高的应用。
- 社区支持和文档：Log4j和Logback拥有丰富的社区资源和文档，而Log4j2虽然相对较新，但也在迅速发展。
- 兼容性：如果已有代码依赖于Log4j，迁移至Log4j2可能更直接；如果使用SLF4J，Logback是一个很好的选择。

总的来说，Log4j2是目前推荐的选择，因为它结合了Log4j的广泛使用和Logback的性能优势，并且在安全性上有所增强。然而，具体选择应根据项目需求和团队偏好来定。

### 日志门面（Logging Facade）

日志门面则是一种抽象层，它提供了一组统一的API接口，使得应用程序的代码可以不直接依赖于任何特定的日志实现。这样做的好处在于，开发者可以在不修改代码的情况下，灵活地切换底层的日志实现框架。日志门面通常不直接参与日志的记录工作，而是将调用转发给绑定的实际日志框架。主要的日志门面有：

1. Apache Commons Logging (JCL)：较老的日志门面，允许运行时切换日志实现，但存在类加载问题，逐渐被SLF4J取代。
2. SLF4J (Simple Logging Facade for Java)：目前最流行的日志门面之一，提供了简洁的API和良好的灵活性。

关系与应用场景

- 应用开发：开发者倾向于在代码中直接使用日志门面（如SLF4J），这样可以在不改变代码逻辑的情况下，根据项目需求或性能测试结果灵活更换日志实现（从Logback切换到Log4j2，反之亦然）。
- 库开发：由于库可能被集成到使用不同日志框架的应用中，所以推荐库开发者使用日志门面的API，以便更好地兼容各种日志实现。
- 系统集成：在集成多个组件或库时，如果各组件使用了不同的日志实现，可以通过桥接器（如SLF4J到Log4j的桥接）确保所有日志行为的一致性。

总之，日志系统负责具体的日志处理逻辑，而日志门面提供了一个标准化的接口，使得应用能够独立于具体的日志实现，从而提高代码的可维护性和灵活性。

## Lombok包

Lombok是一个Java库，它通过提供一组简洁的注解来减少Java代码中的样板代码量。其作用包括：

- **简化代码**：通过使用Lombok注解，可以自动生成常见的Java代码，如getter和setter方法、equals和hashCode方法、toString方法等，从而减少手动编写这些重复代码的工作量。
- **提高可读性**：减少了冗长的样板代码，使得代码更加简洁、清晰，提高了代码的可读性和可维护性。
- **提高开发效率**：减少了编写重复代码的时间，开发人员可以更专注于业务逻辑的实现，提高了开发效率。
- **避免错误**：通过自动生成的代码，减少了手动编写代码的错误可能性，提高了代码的质量和稳定性。

**使用：**

使用 Lombok 非常简单，只需在 Java 类中添加相应的注解即可。以下是一些常用的 Lombok 注解及其使用方式：

- **@Getter/@Setter**：用于自动生成字段的 getter 和 setter 方法。示例：

  ```
  java复制代码import lombok.Getter;
  import lombok.Setter;
  
  public class MyClass {
      @Getter @Setter private int id;
      @Getter @Setter private String name;
  }
  ```

- **@ToString**：用于自动生成 `toString()` 方法。示例：

  ```
  java复制代码import lombok.ToString;
  
  @ToString
  public class MyClass {
      private int id;
      private String name;
  }
  ```

- **@EqualsAndHashCode**：用于自动生成 `equals()` 和 `hashCode()` 方法。示例：

  ```
  java复制代码import lombok.EqualsAndHashCode;
  
  @EqualsAndHashCode
  public class MyClass {
      private int id;
      private String name;
  }
  ```

- **@Data**：结合了 `@Getter`、`@Setter`、`@ToString`、`@EqualsAndHashCode` 的功能，用于生成所有这些方法。示例：

  ```
  java复制代码import lombok.Data;
  
  @Data
  public class MyClass {
      private int id;
      private String name;
  }
  ```

- **@AllArgsConstructor/@NoArgsConstructor**：用于生成带参数的构造方法和无参构造方法。示例：

  ```
  java复制代码import lombok.AllArgsConstructor;
  import lombok.NoArgsConstructor;
  
  @AllArgsConstructor
  @NoArgsConstructor
  public class MyClass {
      private int id;
      private String name;
  }
  ```

通过添加这些注解，Lombok 将在编译时自动生成相应的方法，从而减少了手动编写这些常见代码的工作量。需要确保项目中已经正确配置了 Lombok 插件，以及 IDE 中支持 Lombok 的自动生成功能。

# 其他





## CAS

CAS（Central Authentication Service）是一个开源的企业级单点登录解决方案，提供了统一的身份认证和授权服务。它的核心思想是将认证服务从应用中独立出来，通过一个单独的认证中心来处理用户的身份验证请求，从而实现多个应用之间的单点登录（SSO）。

以下是 CAS 的一些重要特性和详解：

1. **单点登录（SSO）**：
   - CAS 提供了单点登录功能，用户只需在 CAS 认证中心登录一次，即可在同一域下的所有应用中访问，无需重复登录。
   - 用户登录后，CAS 会颁发一个票据（Ticket），应用可以通过票据向 CAS 验证用户身份。

2. **统一认证管理**：
   - CAS 提供了统一的身份认证和授权管理，将认证逻辑集中到一个独立的认证中心。
   - 开发者可以在 CAS 中配置用户认证方式、授权策略等，实现统一的身份管理。

3. **多种认证方式**：
   - CAS 支持多种认证方式，包括基于用户名密码的表单认证、LDAP 认证、数据库认证等。
   - 开发者可以根据项目需求选择合适的认证方式，并进行相应的配置。

4. **单点登出（SLO）**：
   - CAS 提供了单点登出功能，用户在任一应用注销时，CAS 可以通知其他应用注销当前用户的会话。
   - 这样可以确保用户在整个会话中只需登录一次，提高用户体验。

5. **安全性**：
   - CAS 采用了多种安全机制，包括票据验证、加密传输、防止重放攻击等，保障用户身份和数据的安全性。
   - 开发者可以通过配置加强 CAS 的安全性，确保认证过程的可靠性和安全性。

6. **可扩展性**：
   - CAS 是一个开源项目，提供了丰富的扩展点和定制选项，可以根据需求进行定制和扩展。
   - 开发者可以通过插件、扩展、自定义认证处理器等方式扩展 CAS 的功能和特性。

总的来说，CAS 是一个功能强大、安全可靠的单点登录解决方案，可以帮助企业实现统一的身份认证和授权管理，提高用户体验，简化开发和维护工作。

**使用示例**

使用 CAS 作为 Spring Boot Security 的身份认证方案，需要进行一些配置。以下是一个简单的示例，演示了如何将 CAS 整合到 Spring Boot Security 中：

```
java复制代码import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.cas.ServiceProperties;
import org.springframework.security.cas.authentication.CasAssertionAuthenticationToken;
import org.springframework.security.cas.web.CasAuthenticationEntryPoint;
import org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.authentication.logout.LogoutFilter;
import org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll() // 允许访问公开资源
                .anyRequest().authenticated() // 其他请求需要认证
                .and()
            .logout()
                .logoutUrl("/logout") // 登出路径
                .permitAll() // 登出不需要认证
                .and()
            .addFilterBefore(casLogoutFilter(), LogoutFilter.class)
            .exceptionHandling()
                .authenticationEntryPoint(casAuthenticationEntryPoint());
    }

    @Bean
    public CasAuthenticationEntryPoint casAuthenticationEntryPoint() {
        CasAuthenticationEntryPoint entryPoint = new CasAuthenticationEntryPoint();
        entryPoint.setLoginUrl("https://your-cas-server.com/login");
        entryPoint.setServiceProperties(serviceProperties());
        return entryPoint;
    }

    @Bean
    public ServiceProperties serviceProperties() {
        ServiceProperties serviceProperties = new ServiceProperties();
        serviceProperties.setService("https://your-application.com/login/cas");
        serviceProperties.setSendRenew(false);
        return serviceProperties;
    }

    @Bean
    public CasLogoutFilter casLogoutFilter() {
        CasLogoutFilter filter = new CasLogoutFilter("https://your-cas-server.com/logout");
        filter.setLogoutRequestMatcher(new AntPathRequestMatcher("/logout"));
        filter.setLogoutSuccessUrl("/logged-out");
        filter.setFilterProcessesUrl("/logout");
        filter.setServiceProperties(serviceProperties());
        return filter;
    }
}
```

上述配置示例中，假设 CAS 服务器位于 "[https://your-cas-server.com](https://your-cas-server.com/)"，而你的应用位于 "[https://your-application.com](https://your-application.com/)"。你需要将这些 URL 替换为实际的 CAS 服务器和应用程序的 URL。

这个配置示例演示了如何配置 CAS 认证入口点、服务属性以及 CAS 登出过滤器。请根据实际情况进行相应的修改和配置。

同时，你需要在 Spring Boot 项目的配置文件中配置 CAS 服务器的地址、CAS 客户端的信息等相关信息。

### CaSSOFilter

`CasSSOFilter` 过滤器是 CAS（Central Authentication Service）单点登录系统中的一个重要组成部分，用于处理单点登录相关的功能。它的主要作用是拦截用户的登录请求，将其重定向到 CAS 服务器进行统一认证，并处理 CAS 服务器返回的认证结果，最终完成用户在当前系统的登录操作。

具体运用包括：

1. **用户认证**：当用户在系统中进行登录时，`CasSSOFilter` 拦截登录请求，并将用户重定向到 CAS 服务器进行认证。CAS 服务器验证用户身份后，会返回认证成功或失败的结果。

2. **处理认证结果**：根据 CAS 服务器返回的认证结果，`CasSSOFilter` 负责处理用户的登录状态。如果认证成功，用户将被授权访问系统资源；如果认证失败，可能会要求用户重新进行登录或给出相应的错误提示。

3. **单点登录**：通过 CAS 协议，`CasSSOFilter` 实现了单点登录的功能。用户在一个系统中进行登录后，可以在其他系统中自动完成登录，无需重复输入用户名和密码。

4. **会话管理**：`CasSSOFilter` 可能会涉及到会话管理的功能，例如在用户登录成功后，创建或更新用户的会话信息，以及在用户注销时清理会话数据等。

5. **权限控制**：在认证成功后，`CasSSOFilter` 可能会根据用户的权限配置，决定用户能够访问的资源范围，从而实现权限控制的功能。

总的来说，`CasSSOFilter` 运用于 CAS 单点登录系统中，负责拦截用户的登录请求，与 CAS 服务器进行认证交互，并根据认证结果处理用户的登录状态，从而实现单点登录和统一认证的功能。

### SingleSignOutHttpSessionListener

`SingleSignOutHttpSessionListener` 是 CAS（Central Authentication Service）单点登录系统中的一个监听器，用于监听用户会话的销毁事件，从而实现单点登出功能。

具体作用包括：

1. **监听会话销毁事件**：`SingleSignOutHttpSessionListener` 监听用户会话销毁事件，即用户在任意一个系统中注销登录时触发的事件。

2. **发送单点登出请求**：当用户在某个系统中注销登录时，该监听器会收到会话销毁事件，并向 CAS 服务器发送单点登出请求，通知 CAS 服务器注销该用户在其他相关系统中的登录状态。

3. **实现单点登出**：CAS 服务器收到单点登出请求后，会立即注销用户在其他相关系统中的登录状态，从而实现用户在整个系统中的单点登出。

4. **保障安全性**：单点登出功能有助于保障系统的安全性，确保用户在注销登录后不能再访问系统中的受保护资源，从而减少安全风险。

5. **提升用户体验**：单点登出功能简化了用户的操作流程，用户只需要在一个系统中进行注销操作，就能够在所有相关系统中完成退出登录，提升了用户的体验和便利性。

总的来说，`SingleSignOutHttpSessionListener` 的作用是监听用户会话的销毁事件，实现单点登出功能，保障系统的安全性并提升用户体验。

### **Ticket Granting Ticket (TGT)**

TGT 是 CAS 中的一个重要概念，用于表示用户在 CAS 服务器上的登录凭证。用户在第一次登录时，CAS 服务器会颁发一个 TGT，然后使用 TGT 来获取服务票据（Service Ticket）进行单点登录。

### **Service Ticket (ST)**

ST 是 CAS 中的另一个重要概念，用于表示用户访问特定服务的令牌。用户在获得 TGT 后，可以使用 TGT 来向 CAS 服务器请求 ST，然后使用 ST 来访问受保护的服务。
